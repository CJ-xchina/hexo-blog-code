---
title: 笔试计算机知识点
date: 2023-03-18 00:00:00
tags: 
categories: 考研复试
keywords:
description:
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---
<meta name="referrer" content="no-referrer"/>
# 计算机组成原理

## 计算机系统概述

### 问题一、冯诺依曼机基本思想

1. **存储程序**：程序和数据都存储在同一个内存中，计算机可以根据指令集执行存储在内存中的程序。这使得程序具有高度灵活性和可重用性。
2. **指令流水线**：将指令分成若干阶段，每个阶段执行不同的操作，可以在同一时刻处理多条指令。这样可以提高计算机的执行效率。
3. **二进制数系统**：指令和数据都以二进制的形式存储在设备中，计算机能够通过不同指令周期读取的二进制数据加以区分。
4. **存储器层次结构**：计算机系统包含多层存储器，不同层次的存储器提供不同的容量、速度和成本。这种存储器层次结构可以满足不同应用程序对存储器的不同需求。
5. **组成**：计算机由处理器、控制器、存储器、输入设备与输出设备组成，其中计算机是以运算器为中心。

### 问题二、计算机指标

> - **字长（机器字长）**：通常指CPU内部能够用于整数运算的数据通路的宽度，反映了计算机处理信息的能力。通常一台机器的字长与通用寄存器的位数相同。
>   - **指令字长**：一条指令中包含的二进制位数，指令字长是存储字长的整数倍。
>   - **存储字长**：一个存储单元内的二进制代码的长度，与MDR的位数相同。
> - **吞吐量**：单位时间内，某一个系统内处理的请求数量
> - **流水线吞吐率**：单位时间内流水线完成任务数量
> - **流水线加速比：**同一批任务，不使用流水线与使用流水线的时间之比。
> - **CPI**：执行一条指令需要的时钟周期数。
> - **MIPS**：每秒执行的指令数量，单位：百万
> - **MFLOPS/GFPLPS/TFLOPS** ：每秒执行的浮点运算次数，单位：百万/十亿/万亿
>

## 数据的表示

### 问题一、原码，补码，负数补码的转换

**原码 <——> 补码**：从右到左第一个1，这个1左侧的**所有“数值位”**取反。

**补码<——> 负数补码：**从左到右第一个1，这个1左侧的**全部位**取反。

### 问题二、大端存储方式与小端存储方式

数据存储格式：左高右低

大端存储方式：高地址存放在低有效字节（符合人类阅读习惯）

小端存储方式：低地址存放在高有效字节

### 浮点数的表示形式

#### 1、移码

> 移码（又叫增码）是对真值补码的符号位取反，一般用作浮点数的阶码，引入的目的是便于浮点数运算时的对阶操作。
>
> 对于定点整数，计算机一般采用补码的来存储。正整数的符号位为 0，反码和补码等同于原码。负整数符号位为1，原码、反码和补码的表示都不相同，由原码变成反码和补码有如下规则：
> （1）原码符号位为1不变，整数的每一位二进制数位求反得反码；
> （2）反码符号位为1不变，反码数值位最低位加1得补码。
>
> 比如，以一个字节 8bits 来表示 -3，那么 $[ − 3 ] _原 = 10000011$ ，$[ − 3 ]_ 反 = 11111100$，$[ − 3 ] _补 = 11111101$，那么 -3 的移码就是$[ − 3 ] _移 = 01111101$。

#### 2、浮点数的表示

##### 2.1 浮点数的单精度表示

> IEEE754 标准中，一个规格化的 32 位浮点数 x 的真值表示为：
> $$
>  x=(-1)^S\times(1.M)\times2^e
> $$
>
> $$
> e = E - 127
> $$
>
> 其中尾数域值是 1.M。因为规格化的浮点数的尾数域最左位总是 1，故这一位不予存储，而认为隐藏在小数点的左边。
>
> 在计算指数 e 时，对阶码E的计算采用移码的计算方式，因此 32 位浮点数的 8bits 的阶码 E 的取值范围是 0 到 255。其中当E为全 0 或者全 1 时，是 IEEE754 规定的特殊情况，下文会另外说明。

##### 2.2 浮点数的双精度表示

> 64 位的浮点数中符号为 1 位，阶码域为 11 位，尾数域为 52 位，指数偏移值是 1023。因此规格化的 64 位浮点数 x 的真值是：
> $$
> x=(-1)^S\times(1.M)\times2^e
> $$
>
> $$
> e=E-1023
> $$

#### 3、浮点数的存储方式

> IEEE754 标准中规定 float 单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数，即小数部分。对于 double 双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数，其中指数域称为阶码。IEEE754 浮点数的格式如下图所示。
>
> ![image-20230318213641177]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230318213641177.png）
>
> **注意**，IEE754 规定浮点数阶码 E 采用"**指数ｅ的移码-1**"来表示，请记住这一点。为什么指数移码要减去 1，这是 IEEE754 对阶码的特殊要求，以满足特殊情况，比如对正无穷的表示。

#### 4、浮点数的规格化

> 若不对浮点数的表示作出明确规定，同一个浮点数的表示就不是唯一的。例如$（1.75）_{10}$可以表示成 ：$1.11\times2^0,0.111\times2^1,0.0111\times2^2$，等多种形式。
>
> 题目中如果没有说明，那么尾数默认使用原码进行表示：当尾数不为 0 时，**尾数域的最高有效位为1**，这称为<font color='red'>浮点数的规格化</font>。否则，以修改阶码同时左右移动小数点位置的办法，使其成为规格化数的形式。

#### 5、浮点数的特殊表示

> **NaN（非数）**
>
> 31 30             23 22                                                0
>
>  ![img]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/2275830-20211015091757616-387066893.png）
>
>  
>
>  ![img]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/2275830-20211015091821089-753735360.png）
>
>  

> **无穷大**
>
> 31 30             23 22                                               0
>
> **![img]（https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015091843426-307441338.png）**
>
> 无穷用于表达计算中产生的**上溢问题**。比如两个极大的数相乘时，尽管两个操作数本身可以保存为浮点数，但其结果可能大到无法保存为浮点数，必须进行舍入操作。根据IEEE标准，此时不能将结果舍入为可以保存的最大浮点数（因为这个数可能与实际的结果相差太远而毫无意义），而应将其舍入为无穷。对于结果为负数的情况也是如此，只不过此时会舍入为负无穷，也就是说符号域为1的无穷。

> **非规格化数**
>
> 31 30             23 22                                               0
>
> **![img]（https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015091951553-1778330150.png）**
>
>  
>
> **在这种情况下，指数值 E=1-Bias（单精度下即为1-127=-126），而有效数字的值 M=f，也就是说它是小数段的值，不包含隐含的开头的 1。**
>
> **![img]（https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015092029485-1718188036.png）**

## 指令系统

### 问题一、基址寻址与变址寻址的区别

> **基址寻址（Base Addressing）**是一种寻址方式，它通过将一个基础地址和一个偏移地址相加得到访问的地址。基址寄存器存储基础地址，偏移地址可以是一个常量或者是一个寄存器的值，**基址寻址是面向操作系统的**。基址寻址可以让程序员将程序中的逻辑地址转换为物理地址，从而实现访问内存的功能，有利于多道程序设计。
>
> **变址寻址（Indexed Addressing）**是一种寻址方式，它通过将一个基础地址和一个偏移地址相加得到访问的地址，这个偏移地址是由一个寄存器存储的值加上一个常量得到的，**变址寻址方式是面向用户的**。这种寻址方式适用于随机访问数组，编制循环程序。

### 问题二、RISC 与 CISC 的比较

![image-20230301190304958]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230301190304958.png）

## 中央处理器

### 问题一、指令周期的构成

> 1. 取指周期：读取PC的值送入MAR中，读取内存中的指令放入MDR后放回IR（指令寄存器）。
> 2. 间址周期：根据操作数的寻址方式获取操作数的物理地址。
> 3. 执行周期：取出操作数，执行指令。
> 4. 中断周期：保护程序断点。
>

### 问题二、简述一下什么是指令流水线

流水线（pipeline）是一种提高计算机CPU效率的技术，它通过将指令执行过程拆分成多个阶段，让每个阶段可以独立执行，并且在同一时刻可以有多个指令在不同阶段执行，从而提高指令执行的吞吐量和效率。

#### 流水线的冒险

##### 数据冒险（数据冲突）

> - 概念：数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。
> - 解决办法：
>   - **数据旁路技术（转发机制）**：不等前一条指令把计算结果写回寄存器组，下一条指令不再读寄存器组，而是直接把前一条指令的计算结果作为自己的输入数据开始计算过程
>   - **暂停流水线**：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞（stall）和软件插入“NOP”两种方法
>   - **编译优化**：通过编译器调整指令顺序来解决数据相关
>
> **数据冒险的分类**：
>
> - **写后读（RAW）相关**：按序发射，按序完成时，只可能出现 RAW 相关
>
> ```none
> // R5 发生冲突
> I1：ADD R5，R2，R4      （R2）+（R4） -> R5 // 往 R5 写入
> I2：ADD R4，R5，R3      （R5）+（R3） -> R4 // 从 R5 读出
> ```
>
> - **读后写（WAR）相关**：乱序发射，编写程序的时候希望 I1 在 I2 前完成，但优化手段导致 I2 在 I1 前发射
>
> ```none
> // 编译优化后，导致 I2 先执行，I1 后执行，R2 发生冲突
> // 或 I2 可能比 I1 先完成，导致 M 存储的是 （R4）+（R5） 的结果，而不是原本 R2 的值
> I1: STA M，R2           （R2） -> M, M 为主存单元
> I2: ADD R2，R4，R5      （R4）+（R5） -> R2
> ```
>
> - **写后写（WAW）相关**：存在多个功能部件时，后一条指令可能比前一条指令先完成
>
> ```none
> // I2 可能比 I1 先完成，导致 R3 最后存储的是 （R2）*（R1） 的结果，而不是 （R4）-（R5） 的结果
> I1: MUL R3，R2，R1      （R2）*（R1） -> R3
> I2: SUB R3，R4，R5      （R4）-（R5） -> R3
> ```
>

##### 结构冒险（资源冲突）

> - 概念：由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关
> - 解决办法：
>   - 暂停流水线：后一相关指令暂停一个时钟周期
>   - 资源重复配置：数据存储器 + 指令存储器
>

##### 控制冒险

> - 概念：当流水线遇到**转移指令和其他改变 PC 值的指令**而造成断流时，会引起控制相关
> - 解决办法：
>   - 转移指令分支预测：简单预测（永远猜 true 或 false）、动态预测（根据历史情况动态调整）
>   - 预取转移成功和不成功两个控制流方向上的目标指令
>   - 加快和提前形成条件码
>   - 提高转移方向的猜准率
>

---

### 问题三、简述一下指令执行的阶段

> 1. **取指（IF）**：读取指令
> 2. **译码/读寄存器（ID）**：译码 + 读取寄存器中的操作数
> 3. **执行/计算地址（EX）**：执行运算操作或计算地址
> 4. **访存（MEM）**：写回内存
> 5. **写回（WB）**：写回寄存器堆  
>

### 问题四、什么是指令，什么是程序

指令是计算机处理器的基本操作命令，它们被编码成二进制形式，由计算机硬件执行。每个指令执行一个特定的任务，如加法、比较、跳转等。

一个程序是一组计算机指令的有序序列，通常用来完成某个特定的任务。它是一个编写好的代码文件，可以被编译器或解释器转换为计算机可以执行的指令序列。

## I/O方式

### 程序中断方式

#### 问题一、中断优先级

中断优先级包括**中断响应优先级**与**中断处理优先级**

- **中断响应优先级**：实际 CPU 响应中断请求的先后顺序，由硬件排队器实现，其无法被改变。
- **中断处理优先级**：优先级更高的中断会优先被处理，中断处理优先级可以由中断屏蔽字来改变。

> 【注意】
>
> ​	每一个中断源都有一个**中断请求标记触发器**与**中断屏蔽触发器**
>
> - 中断请求触发器为“1”时，表示中断源有请求
>- 中断屏蔽触发器为“1”时，表示屏蔽该中断源的请求。
> 
> 中断屏蔽触发器可以实现：中断处理优先级调整、多重中断。

#### 问题二、CPU响应中断的条件

> 1. 中断源有请求
> 2. CPU 开中断（异常和不可屏蔽中断不受其限制）
> 3. 处于中断周期
>

#### 问题三、中断过程

一个完整的中断过程包括**中断响应过程**和**中断处理过程**。

##### 中断响应过程

此过程由硬件自动完成，又称为中断隐指令，它并不是一条具体的指令，其过程如下：

- **关中断**：保护断点和转移到中断服务程序的操作必须一气呵成，不能被再次中断。
- **保存断点**：将原程序的断点存入堆栈或主存指定单元。
- **引出中断服务程序**：识别中断源，取出中断服务程序的入口地址并传送给程序计数器（PC）。

###### 注意几个要点

**（1）断点、现场：**

> - 断点信息：指令无法读取的寄存器内容，如 PC、PSW 的内容。发生中断时，它们由<font color='red'>硬件自动完成保护</font>。
> - 现场信息：指令可以读取的寄存器内容，如通用寄存器等。发生中断时，它们由<font color='red'>软件（即程序员）完成保护</font>，通常由中断服务程序中的指令把它们存入堆栈或主存指定单元。

**（2）引出中断服务程序（硬件向量法之中断向量法）的过程：**

> **识别中断源**-->**中断类型号**--（中断向量地址形成部件）-->**中断向量地址**-->**中断向量**-->**中断服务程序入口**

**（3）中断向量地址、中断向量、中断向量法、向量中断：**

> - 中断向量地址：中断向量表的各个表项的地址，即**中断服务程序的指针的指针**（存放中断向量的地址）。
> - 中断向量：中断向量表的各个表项的内容，指向中断服务程序的入口，即**中断服务程序的指针**。
> - 中断向量法：这种中断方法被称为中断向量法。
> - 向量中断：采用中断向量法的中断被称为向量中断。

下面是一张中断向量表：

| 中断向量地址（中断向量的存储地址） | 中断向量（指向中断服务程序的入口） |
| ---------------------------------- | ---------------------------------- |
| 0000 0000H                         | 1234 5678H                         |
| 0000 0004H                         | 6666 8888H                         |
| 0000 0008H                         | 4567 8901H                         |
| ......                             | ......                             |

##### 中断处理过程

此过程由**中断服务程序（软件）**完成，其过程如下：

- **保护现场和屏蔽字**：保存通用寄存器和状态寄存器的内容。
- **开中断**：允许更高优先级中断请求得到响应，实现中断嵌套。
- **执行中断服务程序**：中断主体部分。
- **关中断**：恢复现场的操作必须一气呵成，不能被再次中断。
- **恢复现场**：恢复原来通用寄存器和状态寄存器的内容。
- **开中断、中断返回**：通过中断返回指令回到原程序断点处，执行该指令时，硬件自动恢复断点信息。

----

### DMA方式

#### DMA 传送过程

**（1）预处理**：

- DMA 控制器（DMAC）接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出总线请求。
- CPU 响应此总线请求，发出总线响应信号，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。

**（2）数据传送**：

- CPU 向 DMA 控制器指明传送数据的主存单元地址及长度，以及数据在主存和外设间的传送方向。
- DMA 控制器发出读写等控制信号，执行数据传送操作。每传送一个数据，自动修改主存地址计数和传送长度计数。

**（3）后处理**：

- DMA 控制器向 CPU 报告 DMA 操作的结束，执行中断服务程序。恢复 CPU 的一切权利。

#### DMA 传送方式

主存和 **<font color='red'>DMA 控制器</font>** 之间有一条数据通路，不通过 CPU。但当 I/O 设备和 CPU
同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方法使用主存：

- **停止 CPU 访问主存**：CPU 处于不工作状态，未充分发挥 CPU 对主存的利用率。
- **DMA 与 CPU 交替访存**：一个 CPU 周期，分为 C1 和 C2 两个周期，C1 专供 DMA 访存，C2 专供 CPU 访存。
- **周期挪用（周期窃取）**：DMA 访存时有三种可能：CPU 此时不访存（不冲突）；CPU 正在访存（存取周期结束让出总线）；CPU 与 DMA 同时请求访存（I/O 访存优先）。

> 【注意】这里的周期指的是**存取周期**！
>
> DMA 控制器：对传送过程进行控制的硬件
>
> DMA、Cache 通道均为硬件

#### DMA 方式与中断方式的比较

| 项目     |                中断方式                 | DMA 方式                                          |
| -------- | :-------------------------------------: | ------------------------------------------------- |
| 数据传送 | 程序控制（程序的切换-->保存和恢复现场） | 硬件控制（CPU只需进行预处理和后处理）             |
| 中断请求 |                传送数据                 | 后处理                                            |
| 响应     |       指令执行周期结束后响应中断        | 每个机器周期结束均可，总线空闲时即可响应 DMA 请求 |
| 场景     |            CPU控制，低速设备            | DMA控制器控制，高速设备                           |
| 优先级   |              优先级低于DMA              | 优先级高于中断                                    |
| 异常处理 |             能处理异常事件              | 仅传送数据                                        |



# 操作系统

## 操作系统组成

### 中断与异常

**中断与异常的概念**

- **中断**（Interruption） 也称外中断，指外部事件打断了CPU正在执行的程序的执行流程，使得CPU需要立即响应事件，执行特定的操作。  

- **异常**（Exception） 也称内中断，是指来自CPU执行指令内部的事件。

**中断与异常的分类**

-  中断包括：可屏蔽中断（INTR）和不可屏蔽中断（NMI）
- 异常包括：故障（Fault）、自陷（Trap）、终止（Abort）。故障是由指令执行时引起的异常，例如缺页故障、除数为0，自陷是一种是先安排好的“异常”事件，而终止是出现了使 CPU 终止的硬件故障。

| 异常种类         | 例子                                                         |
| :--------------- | ------------------------------------------------------------ |
| 故障（软件中断） | 非法操作码、访存缺段、访存缺页、地址越界、除数为 0、浮点运算上溢 |
| 自陷（软件中断） | 通过执行陷入指令来进行**系统调用**，此时 CPU 从**用户态**陷入到**内核态**；调试、断点事件；**访管指令**或陷入指令 |
| 终止（硬件中断） | 控制器出错、存储器校验错                                     |

> 【注意】
>
> - 异常不可被屏蔽。
> - Cache 缺失不会引起异常，因为 Cache 缺失和虚拟存储器缺页缺段不是一个原理。
> - 软件中断又称为**程序性异常**。

**中断与异常的响应时间**

- 中断：只能在指令周期中的中断周期被响应，即一条指令的最后
- 异常：能够在发起异常的下一个时钟周期就得到响应，应该是很快或者是立刻。

**中断与异常的返回位置**

- 中断：返回下一条指令
- 异常：故障返回当前指令，自陷返回下一条指令，终止无法执行指令。

### 内核态与用户态

> **内核态（Kernel Mode）**与 **用户态（User Mode）**：是CPU运行的两种模式。
>
> - **内核态**是操作系统核心代码运行的特权级别。在内核态中，操作系统有完全的访问权限和控制权限，可以执行任意指令、使用任意寄存器、访问系统内存和硬件资源。内核态可以执行系统级别的操作，如创建和销毁进程、分配内存、读写硬件设备等等。由于内核态具有最高的特权级别，因此在该模式下执行的代码具有非常高的安全风险，因此只有操作系统核心代码可以运行在内核态中。
> - **用户态**是应用程序运行的特权级别。在用户态中，应用程序只能访问到分配给它的资源和内存，不能直接访问系统内存或硬件资源。应用程序不能执行特权指令或系统调用，这些操作只能通过操作系统提供的接口来实现。用户态运行的程序具有较低的特权级别，因此不能访问内核态中的数据或资源。
>
> ***CPU工作状态的切换*：**
>
> - 用户态 -> 内核态：通常是使用访管（Trap）命令实现，也就是常说的陷入机制。同时还可以通过中断、异常来实现切换。
>
> - 内核态 -> 用户态：由一条改变 psw（程序状态字寄存器） 值的特权指令来实现。
>

### 微内核（Micro kernel）

> 微内核是操作系统的一种内核架构模式，相较于宏内核，在微内核架构的操作系统中，只有操作系统的核心功能例如：时钟管理、中断处理、原语操作被放入内核内部，而例如进程管理、存储管理、设备管理等功能则在用户态中实现。
>
> 微内核具有更高的可扩展性与可靠性，操作系统中一个模块的崩溃并不会导致整个操作系统的崩溃，同时微内核还是采用**客户/服务器模式**，内核看做客户端，用户态的进程看做服务器端，两者通过消息传递机制实现通信。
>
> 但是相较于宏内核设计模式，微内核服务的实现需要频繁切换用户态与核心态，且用户态的各个功能模块不能直接调用，而是通过内核的"消息传递机制"实现，这回导致相较于宏内核架构模式，微内核的性能更低。

### 系统调用

#### 什么是系统调用？

> 知识点回顾：
>
> 操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括**命令接口**和**程序接口**。其中，程序接口由一组系统调用组成。
>
> ![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/a6bdbcd450994cd09e661414100571d9.png）
>
> 联机命令接口（输入一个执行一个）：用户可以使用联机控制命令来对自己的作业进行控制，联机用户接口可以实现用户与计算机的交互
>
> 脱机命令接口（输入一堆执行一堆）：也称为批处理用户接口，用户使用JCL（用户控制语言）写好作业说明书，将其和作用的程序和数据一起提交给计算机，OS将逐条按JCL自动控制作业的执行。
>
> 系统调用（仅程序能调用）：操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。**

#### 小例子：为什么系统调用是必须的？

![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/608072df08914c939f88dcbb6da30bc4.png）

#### 什么功能要用系统调用实现？

应用程序通过`系统调用`请求操作系统的服务。而系统中的各种共享资源都由`操作系统内核`统一掌管，因此<font color='red'>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成</font>。这样可以`保证系统的稳定性和安全性`，防止用户进行非法操作。

![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/0286b00ce17946f0b7a06031379d9d61.png）

系统调用相关处理涉及到对系统资源的管理、对进程的控制,这些功能需要执行一些`特权指令`才能完成,因此`系统调用的相关处理`需要在`核心态`下进行。

#### 系统调用的过程

![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/c20b954011d04fa78c0c060550884afc.png）

#### 系统调用与库函数的区别

![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/97a1c6e6657f4b729aa07809e4c5beb5.png）

#### 系统调用与过程调用的区别与联系

> 区别：
>
> 1. 目的不同：系统调用是为了访问操作系统**内核中提供的功能**而调用的，而过程（函数）调用是为了执行**程序中的某些特定代码块**而调用的。
> 2. 调用方式不同：系统调用需要使用软件中断（int 0x80）等方式进行调用，进入内核空间进行相应的操作；而过程（函数）调用只需要使用CALL指令即可。
> 3. 运行环境不同：系统调用是在内核态下运行的，需要切换用户态与内核态，进入内核空间运行，而过程（函数）调用是在用户态下运行的。
> 4. 运行效率不同：由于需要进行用户态与内核态的切换，系统调用的效率相对较低，而过程（函数）调用则无需进行此操作，相对更快。
> 5. 安全性不同：系统调用需要进入内核空间进行操作，可以实现对硬件资源的管理和保护，因此比过程（函数）调用更加安全可靠。

> 联系：
>
> 1. 参数传递方式相同：系统调用和过程调用都需要将参数传递给被调用的函数或服务。
> 2. 返回值方式相同：系统调用和过程调用都需要返回值来告诉调用者执行的结果。

## 线程进程

### 问题1、进程和程序的比较

- 程序是存放在文件系统的比特信息，是永存的；而进程是暂时的，是程序在数据集上的一次执行；
- 程序是静态的观念；进程是动态的观念，其可以被创建、阻塞、终止。
- 进程具有并发性，而程序没有；
- 进程是计算机资源的分配基本单位，程序不是。

---

### 问题2、什么是进程,什么是线程?

**进程**是操作系统中资源分配基本单位，表示一个正在运行的应用程序或任务。每个进程都有一个独立的地址空间，可以独立地运行并占用系统资源。

**线程**是操作系统中的调度单位，是程序执行流的最小单元。每个线程有独立的程序计数器、调用栈和寄存器，但共享同一进程的其他资源。

进程与线程的区别在于，进程是独立的资源分配单位，线程是进程的一部分，是进程内部的执行流。因此，创建和管理进程的代价比较大，但每个进程独立运行，它们之间互不干扰。而创建和管理线程的代价较小，但它们共享同一进程内的资源，如果一个线程发生异常，可能会影响到其他线程的正常运行。

> 补充 : 父子进程可以共享资源但不共享存储空间，而进程与线程既可以共享资源也可以共享空间。
>

---

### 问题3、有了进程为什么需要线程?

答 ：在引入线程之前，进程是操作系统中资源分配和调度的基本单位，它可以独立运行并占用系统资源，但是进程的创建和切换都是有代价的，因此，对于一些需要高效执行的任务，如果使用进程进行处理，就可能带来较大的开销。

引入线程之后，线程是进程的一个执行单元，它成为了调度的基本单位，它可以共享进程的资源，而不需要独占系统资源，因此创建和切换线程的开销要远小于进程。同时，由于线程的轻量级特性，系统可以快速切换线程，从而使程序具有较好的响应速度。

### 问题4、同步互斥机制遵循的原则

答：1、空闲让进 		2、忙则等待		3、有限等待		4、让权等待

### 问题5、死锁

> - 死锁的定义：两个或多个进程因竞争资源或者互相等待对方释放资源而造成的一种僵局现象。在死锁状态下，进程们会一直等待对方释放资源，不能继续执行，占用的系统资源也无法释放，导致系统长时间处于不可用状态。
>
> - 死锁产生的原因：互斥、不可剥夺、请求与保持、循环等待。
> - 死锁解除的方式：
>   - **死锁预防**：破坏互斥条件（不可行），破坏不可剥夺条件（请求得不到满足时放弃所有不可剥夺资源），破坏请求与保持条件（一次分配所有进程需要的资源），破坏循环等待条件（顺序资源分配法，只能按照编号递增的顺序分配资源）
>   - **死锁避免**：银行家算法判断分配后是否处于系统安全状态
>   - **死锁检测** **+ 死锁解除**：利用资源分配图检测死锁，利用资源剥夺、进程撤销、进程回退的方式解除死锁。
>

### 问题6、PV操作

#### 6.1 司机售票员问题

![在这里插入图片描述]（https://img-blog.csdnimg.cn/20200712213327643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0MzY0Mjc=,size_16,color_FFFFFF,t_70）

#### 6.2 哲学家进餐问题

```c++
semaphore chopstick[6] = {1, 1, 1, 1, 1, 1};
semaphore mutex = 1;

// i 号哲学家进程
pi（） {
     while（true） {
          p（mutex）;
          p（chopstick[i]）;
          p（chopstick[（i + 1） % 6]）;
          进餐;
          v（chopstick[i]）;
          v（chopstick[（i + 1） % 6]）;
          v（mutex）;
          思考;
     }
}
```

### 问题7、PCB中存有哪些数据

![image-20230318210508838]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/844b3298d445010757512693241846e.jpg）

### 问题8、线程的实现方式

#### 1、用户级线程

##### 1.1 用户级线程实现方式

> 在**用户级线程**中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在. **应用程序可以通过使用线程库设计成多线程程序.** 通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。
>
> 对于设计了用户级线程的系统，其调度仍是以进程为单位进行的，各个进程执行一个时间片。
>
> ![image-20230318221032012]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230318221032012.png）
>
> 例如下面的代码模拟了定义了用户级线程：
>
> ```c++
> int mian（） {
>      int i = 0;
>      while（1） {
>           if （i % 3 == 0） {处理视频聊天的代码;}
>           if （i % 3 == 1） {处理文字聊天的代码;}
>           if （i % 3 == 2） {处理文件传输的代码;}
>      }
> }
> ```
>
> 如果将每一个操作都比作一个线程，看上去线程之间并发执行，单其实这些线程公用一个进程的处理机资源，线程的切换也只是在用户层用条件判断语句来控制，如果一个用户级线程阻塞（例如在某个代码处打上断点），整个进程中的所有用户级线程均无法运行。同时，拥有更多代码行的用户级进程能更多地占用处理机资源，这显然是不公平的。

##### 1.2 用户级线程的优势

> 1. 可以在不支持线程的操作系统中实现。
> 2. 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程
> 3. 允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别
> 4. 线程能够利用的表空间和堆栈空间比内核级线程多
> 5. 不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷
> 6. 线程的调度不需要内核直接参与，控制简单。

##### 1.3 用户级线程的缺陷

> 1. 线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行
> 2. 一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程
> 3. 资源调度按照进程进行，多个处理机下，不能充分发挥处理机的优势

#### 2、内核级线程

##### 2.1 内核级线程的实现方式

> 在**内核级线程**中，内核线程建立和销毁都是由操作系统负责、通过系统调用完成的。在内核的支持下运行，无论是用户进程的线程，或者是系统进程的线程，他们的创建、撤销、切换都是依靠内核实现的。
> 内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射，
>
> 1. 线程的创建、撤销和切换等，都需要内核直接实现，即内核了解每一个作为可调度实体的线程
> 2. 这些线程可以在全系统内进行资源的竞争
> 3. 内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制
>
> ![image-20230319111109688]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230319111109688.png）
>
> 如图所示,即内核级线程的实现方式, 每个用户线程都直接与一个内核线程相关联.

##### 2.2 内核级线程的优势

> **①能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。**
>
> **②如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。**
>
> **③内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。**
>
> **④内核本身也可采用多线程技术，可以提高系统的执行速度和效率。**

##### 2.3 内核级线程的缺陷

> 相较于用户级线程，同一进程钟的线程切换，需要从用户态切换到核心态进行，系统的开销更大。

#### 3、组合方式

结合前两种实现方式的优点，同时也更加灵活：

![image-20230318221503177]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230318221503177.png）

## 内存管理

### 空闲内存管理

#### 连续分配管理方式

##### 单一连续分配

> 一个程序独占整个用户区
>
> 特点：**无外部碎片，有内部碎片**

##### 固定分区分配

> 将用户空间划分为若干个分区，每个分区只装入一道作业
>
> 特点：**无外部碎片，有内部碎片**

##### 动态分区分配

> 根据进程的实际需要，动态为其分配内存空间，并使这些空间刚好够进程使用。
>
> 特点：**无内部碎片，有外部碎片**

> **动态分区分配算法：**
>
> - 首次适应算法（First Fit）：地址递增排列
> - 最佳适应算法（Best Fit）：容量递增排列
> - 最坏适应算法（Worst Fit）：容量递减排列
> - 临近适应算法（Next Fit）：地址递增排列
>
> ![img]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/c49adda15eb9473589f04003dab7d26c.png）

### 程序装入内存步骤

> ![image-20230224222611696]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230224222611696.png）
>
> - **预处理**：预处理器可以删除注释、包含其他文件以及执行宏替代。
> - **编译**：编译预处理修改后的源文件生成编译程序文本（.s）。
> - **汇编**：汇编器将生成的汇编语言代码翻译为二进制目标程序（.o）。
> - **链接（生成逻辑地址）**：将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件（.exe）。链接方式有：
>   - **静态链接**：运行前先将目标模块连接成一个完整的配置模块并不会再次拆开。
>   - **装入时链接**：在装入内存时，采用边装入，边链接的方式。
>   - **运行时链接**：当目标模块被使用时，才会将目标模块装入。
> - **装入（生成物理地址）**：装入方式：
>   - **绝对装入**：只适用于单道程序，连接结束后将程序驻留在与逻辑地址相同的内存地址上不在变动。
>   - **静态重定位**：在装入时修改程序的指令和数据的地址，没有足够的内存空间就无法装入。
>   - **动态重定位**：装入内存的程序其所有地址为相对地址，当程序真正执行时再通过定位寄存器计算物理地址，只需要装入一部分程序即可投入运行。
>

## 文件管理

### 文件系统

#### 问题一、文件系统的定义

> **文件系统**是指一种组织和管理计算机存储设备上文件和目录的方式。它提供了一种标准化的方法来存储、访问、管理和维护文件和目录，使得用户可以方便地访问和管理存储在存储设备上的数据，<font color='red'>磁盘上的每一个分区都可以拥有独自的文件系统</font>。
>
> 常见的文件系统包括FAT、NTFS、EXT2/EXT3、HFS+等。
>

#### 问题二、虚拟文件系统的定义

> 虚拟文件系统是一种抽象层，用于在操作系统中提供文件系统的统一接口。它可以让操作系统支持多种文件系统，并且使得不同的文件系统可以共享同一组API，使得用户和应用程序可以使用相同的接口来访问不同类型的文件系统。
>
> 虚拟文件系统向上层提供了统一的标准的系统调用接口，并要求下层的文件系统必须实现某些规定的函数功能。
>



#### 问题三、操作系统的引导流程

> 1. CPU激活：激活CPU读取ROM中的boot程序，将指令寄存器设置为BIOS的第一条指令，执行BIOS程序。 
> 2. BIOS自检：随后BIOS会进行自检，检查硬件设备是否正常。
> 3. MBR（主引导记录）程序加载：BIOS会查找硬盘的MBR 区域，并将MBR中的引导程序加载到内存中。MBR的作用是去告诉CPU去硬盘的哪一个分区去找操作系统。
> 4. PBR（分区引导记录）程序加载：读取活动分区的第一个扇区，这个扇区就是分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序。
> 5. 内核初始化：内核加载完成后，会进行一些初始化操作，例如初始化设备驱动程序、建立进程、创建根文件系统等。
> 6. 用户空间初始化：内核初始化完成后，会创建第一个用户进程，并将控制权转移给用户进程，从而进入用户空间。
>



# 计算机网络

### Ethernet连到internet需要的协议

> - **TCP/IP协议**：这是Internet使用的主要协议，用于在不同计算机之间传输数据。它是一个包含一系列规则的协议集合，其中包括IP地址和子网掩码，TCP和UDP等传输协议，以及HTTP、FTP、SMTP等应用层协议。
>
> - **DHCP协议**：动态主机配置协议，可以自动为计算机分配IP地址、子网掩码、默认网关、DNS服务器等网络配置信息。这个协议可以让你方便地将计算机连接到Internet，而无需手动设置网络参数。
>
> - **DNS协议**：域名系统协议，将域名转换为IP地址。当你在Web浏览器中输入一个URL时，浏览器会使用DNS协议将这个域名转换为IP地址，然后建立TCP/IP连接。
>
> - **ARP协议**：地址解析协议，用于将IP地址映射到MAC地址。当你向另一个计算机发送数据时，你需要知道它的MAC地址，而ARP协议就是用于查询和解析这个MAC地址的。

## HTTP协议

### 您输入 URL 时，发生了哪些事？

> 1. **域名解析**：浏览器首先将URL中的域名部分解析成IP地址。浏览器会先查找本地缓存中是否有该域名对应的IP地址，如果没有则会向本地DNS服务器发送查询请求。如果本地DNS服务器缓存中没有该域名对应的IP地址，则会向根域名服务器发送请求，逐级查询直到找到该域名对应的IP地址。
> 2. **建立TCP连接**：一旦浏览器获得了目标服务器的IP地址，它就会使用TCP协议建立与服务器的连接。在建立TCP连接时，浏览器和服务器之间会进行三次握手，确保双方可以可靠地通信。
> 3. **发送HTTP请求**：TCP连接建立后，浏览器会向服务器发送HTTP请求，其中包括请求方法（GET、POST等）、请求头和请求体等信息。请求头包括浏览器类型、所接受的数据格式等信息。
> 4. **服务器处理请求并返回响应**：服务器收到浏览器发送的请求后，会根据请求中的信息进行处理，比如查询数据库、读取文件等操作。服务器处理完请求后，会将处理结果打包成HTTP响应发送回浏览器。
> 5. **浏览器渲染页面**：浏览器接收到服务器返回的响应后，会根据响应中的内容渲染出页面。渲染页面的过程包括解析HTML、CSS和JavaScript等文件，构建DOM树和渲染树等步骤。
> 6. **断开TCP连接**：一旦页面渲染完毕，浏览器会关闭与服务器的TCP连接，页面加载完成。
>

### HTTP协议中 get 与 post 方法有何不同

HTTP协议中，GET和POST方法是最常用的两种请求方法，它们在以下几个方面有所不同：

1. **数据位置**：GET方法将请求数据包含在URL中，而POST方法将请求数据包含在请求体中。因此，GET方法的请求数据会被浏览器缓存，而POST方法的请求数据不会被缓存。
2. **数据长度限制**：由于GET方法的数据包含在URL中，因此URL的长度受到限制。不同浏览器的限制长度不同，但通常在2048个字符左右。而POST方法的数据可以放在请求体中，因此可以包含更多的数据，通常没有长度限制。
3. **安全性**：GET方法将请求数据暴露在URL中，因此不安全，容易被拦截、篡改。而POST方法将请求数据包含在请求体中，不容易被拦截和篡改，因此安全性更高。
4. **使用场景**：通常来说，GET方法适合用于获取数据，比如搜索、过滤、排序等操作。而POST方法适合用于提交数据，比如表单提交、文件上传等操作。

总的来说，GET方法适用于对数据进行查询操作，请求数据量小，对安全性要求不高的场景；而POST方法适用于对数据进行增删改操作，请求数据量大，对安全性要求较高的场景。



# 数据结构

## 树

### 树的基本概念

> 1. 树的基本概念：树是由若干个结点组成的一种层次结构，其中一个结点为根结点，每个结点可以有零个或多个子结点。结点之间的连线称为边，根结点没有父结点，而其他结点都有一个父结点。
> 2. 树的遍历：树的遍历是指按照某种规则依次访问树的所有结点。常见的树的遍历方式有前序遍历、中序遍历和后序遍历。此外，还有层次遍历等方式。
> 3. 二叉树的基本概念：二叉树是一种特殊的树，每个结点最多有两个子结点，分别称为左子结点和右子结点。二叉树有多种类型，例如满二叉树、完全二叉树等。
> 4. 二叉树的遍历：二叉树的遍历方式包括前序遍历、中序遍历、后序遍历和层次遍历。其中前序遍历、中序遍历和后序遍历通常也被称为深度优先遍历。
> 5. 完全二叉树：完全二叉树是一种特殊的二叉树，其中除了最后一层节点可能不满，其他层节点都是满的，而且最后一层节点都靠左排列。
> 6. 平衡树：平衡树是一种特殊的二叉搜索树，它保证在树中查找、插入、删除等操作的时间复杂度为 O（logn）。常见的平衡树包括红黑树、AVL树等。
>



### 二叉树的存储方式

二叉树的存储方式有：**顺序存储方式与链式存储方式。**

#### **顺序存储方式**

![image-20230220155527802]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230220155527802.png）

#### **链式存储方式**

![]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230220155600607.png）



### 树的存储方式

树的存储方式主要有：**双亲表示法、孩子表示法、孩子兄弟表示法**



### 平衡二叉树（AVL）

> 平衡二叉树的插入、删除的调整动作，**每次调整的对象都是最小不平衡子树**，即从插入节点开始向根节点方向的第一个不平衡节点以该节点为根节点的子树！插入操作步骤如下：
>
> 1. 首先，需要将要插入的节点插入到二叉搜索树中的合适位置，与非平衡二叉树的插入操作相同。
> 2. 然后，需要检查插入节点的祖先节点是否平衡。具体来说，从插入节点开始，向上回溯到根节点，每经过一个节点就计算一下它的左右子树的高度差，如果高度差大于1，那么这个节点为根的子树为最小不平衡子树（记为A节点）。
> 3. 如果某个节点不平衡，就需要进行旋转操作来恢复平衡。旋转操作分为左旋和右旋，具体操作如下：
>    - 如果在新插入的节点在A节点左孩子的左子树上，则需要右旋 （LL）
>    - 如果在新插入的节点在A节点右孩子的右子树上，则需要左旋 （RR）
>    - 如果在新插入的节点在A节点左孩子B的右子树上，则需要让左孩子B左旋后A节点再右旋 （LR）
>    - 如果在新插入的节点在A节点右孩子B的左子树上，则需要让右孩子B右旋后A节点再左旋（RL）
>
> [AVL模拟网站]（https://www.cs.usfca.edu/~galles/visualization/AVLtree.html）

### B树与B+树（详细见书本）

---

## 图

### 图的存储

#### 邻接矩阵

![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20200608110653874.jpg）
上图就已经完全解释了邻接矩阵如何实现了存储，就是定义一个图的结构体，然后其中定义俩数组一个放顶点（包括顶点的信息），一个放顶点的位置关系。
那么定义的结构体为：

```c
//图结构体的定义
#define MAX_SIZE 20        //定义的最大存储顶点数目
typedef struct 
{
     VertexType vex[MAX_SIZE];     //定义顶点数组，存放顶点的信息，如果信息复杂了那么自然还要定义顶点的结构体
     AdjMatrix arcs[MAX_SIZE][MAX_SIZE];     //定义的邻接矩阵（顶点位置关系），如果单纯的就表示一些距离值，那么直接定义一个int 类型的二维数组即可，如果顶点间还有其他信息那么就将其定义成一个结构体
     int vexnum,arcnum;    //定义图的顶点数和弧数，弧数就是顶点关系的个数
}Graph;

//初始化图
void init（Graph &G）
{
   int i,j; 
   printf（"请输入顶点数和弧数"）;
   scanf（"%d",&i）;
   scanf（"%d",&j）;
   G.vexnum=i;      //对图的信息进行初始化
   G.arcnum=j;
              
 for（int x=0;x<G.vexnum;x++）      //这里是根据定义的节点数来对矩阵进行初始化
 {
  for（int y=0;y<G.vexnum;y++）
  {
     G.arcs[x][y]=0;     //对图结构中的位置关系进行初始化，先都化为0，表示节点直接都不相连
  }
 }
 
 for（int x=0;x<G.vexnum;x++）
 {
   printf（"输入顶点的信息"）;        //对节点信息进行输入
   scanf（"%s",&G.vex[x]）;         //输入到定义的顶点信息数组中
 }
 
 for（int x=0;x<G.vexnum;x++）
 {
  printf（"请输入要连接的节点"）; 
  int a,b;
    scanf（"%d",&a）;       //按照顶点在位置数组中的序号来写，数组都是从 0 开始的，也可以写一个根据信息来定在数组中位置的函数。
    scanf（"%d",&b）;
    G.arcs[a][b]=1;      //获取了需要连接顶点的位置后，将其对应数组中的位置等于 1，表示相通
   //G.arcs[b][a]=G.arcs[a][b]   若为无向图，自然顶点是互相连通的，所以在数组中也是对称的
 }
}

//输出函数 （就是将图的邻接矩阵输出，就能得到图中顶点的关系）
void printGraph（Graph &G） 
```

这里假设有个例子
![在这里插入图片描述]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20200608142410807.jpg）
要来实现上面的图，顶点信息就存它们顶点的名称。

```c
//结构体定义
typedef struct       //简单点的图结构
{
     char vex[MAX_SIZE];      //顶点信息，这里假设存放字符串，表示他们的顶点
     int arcs[MAX_SIZE][MAX_SIZE];     //位置关系数组
     int vexnum,arcnum;    
}Graph;
init（）;     //一下两个函数定义就不重复写了
printGraph（）;
int main（）
{
   Graph G;
   init（G）;
   printGraph（G）;
}
```

#### 邻接表

![在这里插入图片描述]（	解为一个存储弧信息的表。

首先定义图的结构体框架：（这个例子是带有权值的，应该叫做网，但是为了大家方便理解，就先叫做图吧）

```c
typedef struct ArcNode  //定义图中的表结构，链式表
{
 int adjvex;    //要连接点在数组中的位置
 int arc;     //定义顶点与该连接点之间的权值
 struct ArcNode *next;  //定义下一个节点,链式表之间的链，实现链式表之间的连接
}ArcNode;
 typedef struct VNode   //定义图顶点结构
{
 ArcNode *first;     //每个顶点中的表头的头指针，可根据上面的图像理解
  char vex[10];      //图信息（数据）的存储，这里也可以存储顶点的多个数据，都由自己定，这里就假设存储的是顶点名称
}VNode;              //定义图顶点结构
typedef struct 
{
 VNode NodeList[10];      //定义顶点数组，存放图的顶点，和上面的道理一样
 int vexnum,arcnum;       //定义图的属性，几个顶点几条弧
 }Graph;    //定义图总框架，c语言调用的时候要遵从先后定义顺序，所以该图结构定义在最后面
```

### 图的应用

#### 拓扑排序（AOV）

#### 最小生成树

#### 最短路径

##### Dijkstra算法

Dijkstra常常用于解决单源的最短路径问题，时间复杂度为：$n*logn$，核心思路是贪心算法。

- 参数需求：
  - `path`：存储点与点的路径关系，点与点之间无法直接到达距离为INF
  - `from`：起点索引位置
  - `to`：终点索引位置
- 功能描述：
  - 从`from`点到`to`点的最短距离，如果无法到达则返回 -1

> **Dijkstra算法无法处理边上带有负权值的情况**

```java
// Java版本
final int INF = Integer.MIN_VALUE / 2;

public int dijstra（int path[][], int from, int to） {
    int n = path.length;
    //dist[]保存距离的最小值
    int[] dist = new int[n];
    //used存储使用情况
    boolean[] used = new boolean[n];
    //初始化
    Arrays.fill（dist, INF）;
    dist[from] = 0;
    //开始遍历
    //为什么是 0 ~ n - 1 遍历呢，为了解冗余处理 from 节点的情况，初始化dist与used数组
    for （int i = 0; i < n; i++） {
        //存储下一个结点编号
        int x = -1;
        //遍历寻找最短且没有被使用的结点
        for （int y = 0; y < n; y++） {
            if （!used[y] && （x == -1 || dist[y] < dist[x]）） {
                x = y;
            }
        }
        used[x] = true;
        //更新距离
        for （int iz = 0; iz < n; iz++） {
            dist[iz] = Math.min（dist[iz], path[x][iz] + dist[x]）;
        }
    }
    int ans = dist[to];
    return ans == INF ? -1 : ans;
}


// C++ 版本
#include <stdlib.h>
#include <limits.h>

int *dijkstra（int **path, int from, int size） {
    int* dist = （int*）malloc（size * sizeof（int））;
    int* used = （int*）malloc（size * sizeof（int））;

    for （int i = 0; i < size; ++i） {
        dist[i] = INT_MAX;
        used[i] = 0;
    }
     
    dist[from] = 0;

    for （int i = 0; i < size; ++i） {
        int minDist = INT_MAX;
        int minIdx = -1;
        for （int j = 0; j < size; ++j） {
            if （!used[j] && dist[j] < minDist） {
                minDist = dist[j];
                minIdx = j;
            }
        }
        if （minIdx == -1） break;
        used[minIdx] = 1;
        for （int k = 0; k < size; ++k） {
            if （path[minIdx][k] > 0） {
                int newDist = dist[minIdx] + path[minIdx][k];
                if （newDist < dist[k]） {
                    dist[k] = newDist;
                }
            }
        }
    }
    free（used）;
     // 返回最短路径数组
    return dist;
}

```

##### Floyd算法

Floyd常常用于解决多源最短路径问题，时间复杂度为：$O（N^3）$

- 参数需求：
  - `path`：存储点与点的路径关系，点与点之间无法直接到达距离为INF
- 功能描述：
  - 将`path`数组存储所有点到目标点的最短距离，如果无法到达值为INF

> **Floyd算法允许途中带有权值为负数的边，但是不允许含有负权值边组成的回路**

```java
final int INF = Integer.MIN_VALUE / 2;

// 该版本path数组会被修改
public void floyd（int path[][]） {
    int n = path.length;
    for （int z = 0; z < n; ++z） {
        for （int i = 0; i < n; ++i） {
            for （int j = 0; j < n; ++j） {
                path[i][j] = Math.min（path[i][j], path[i][z] + path[z][j]）;
            }
        }
    }
}
```

---

## 查找

### 查找的基本概念

> **查找**：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找结果一般分为两种即，查找成功查找失败。
>
> **查找表（查找结构）**：用于查找的数据集合称为查找表，可以是一个数组或链表等数据类型
>
> **静态查找表**：若一个查找表的操作仅涉及查询某种元素是否在表中或者检索满足某种特性的数据元素的各种属性，则称该表为静态查找表。（若存在查找插入操作以及删除操作等**修改**了表，则不是静态查找表，反之我们称为**动态查找表**）
>
> **关键字**：数据元素中唯一表示该元素的某个数据项的值，使用基于关键字查找，查找结果应该是唯一的
>
> **平均查找长度**：在查找过程中，一次查找长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字比较次数的平均值，其数字定义为：
> $$
> ASL = \sum_{i=1}^{n}P_iC_i
> $$
> *n 是查找表的长度，$P_i$ 是第$i$个元素出现的概率，$C_i$是找到第$i$个数据所需要的比较次数。*
>
> <font color='red'>平均查找长度是衡量查找算法效率的最主要衡量指标。</font>

### 散列表

#### 散列表定义

> **散列表**：根据关键字而直接访问数据结构，也就是说散列表建立了关键字与存储地址之间的一种直接映射关系
>
> **散列函数**：一个把关键字映射成关键字对应的地址的函数，记为$Hash（key）=addr$。这里的地址可以是索引或数组下标。
>
> **冲突：**但是散列函数可能会把两个或两个以上的不同关键字映射到同一地址上。
>
> **同义字：**这些发生碰撞的不同关键字。好的散列函数应减少这种冲突的出现，但是冲突是客观不可避免的，所以我们也要做好应对冲突的工作。

#### 散列表构造方法

构造散列表的时候必须注意以下几点：

> 1. 散列函数的定义域必须包含全部需要存储的关键字，而值域则依赖于散列表的存储地址空间大小或地址范围
> 2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突地发生
> 3. 散列函数应该尽量简单，能够在较短地时间内计算出任一关键字的散列地址

| 构造方法   | 方法                                                  | 冲突处理              | 特点                                                         |
| ---------- | ----------------------------------------------------- | --------------------- | ------------------------------------------------------------ |
| 直接定址法 | $H（key） = key 或 H（key） = a*key + b$              | 不会出现冲突          | 方法简单。适合关键字分布基本连续的情况（否则有较大的空间浪费） |
| 除留余数法 | $H（key） = key \% p$                                 | 应选好p，从而减少冲突 | 最简单常用的方法                                             |
| 数字分析法 | 设关键字是r进制数，选取码位分布均匀的若干位为散列地址 |                       | 适合于已知关键字集合，若更换了关键字，则需重新构造新的散列函数 |
| 平方取中法 | 取关键字的平方值中间几位作为散列值                    |                       | 适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数   |

在不同情况下，选择相应适合关键字集合的散列函数，不存在哪一种函数最优的情况，但目标是应该尽量减少产生冲突的可能性。

#### 处理冲突的方法

##### **1. 开放地址法**

> 所谓开放地址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放，其数学公式为
> $$
> H_i = (H(key) +d_i)\%m
> $$
> 式中，H（key）为散列函数，m代表散列表长，$d_i$代表增量序列
>
> 1. **线性探测法**：
>    当冲突发生的时候，顺序查看下一个存储单元是否空闲，若空闲放入下一个位置，若否，一直向下查看直至空闲插入
>
> 2. **平方探测法**：
>    当$d_i =0^2,1^2,-1^2,2^2,-2^2,...k^2,-k^2$时，成为平方探测法，其中 k<=m/2。散列表长度m必须是一个可以表示成$4k+3$的素数，可以避免出现堆积问题。但是他不能探测到到所有存储单元，但至少可以探测一半。
>
> 3. **双散列法：**
>    当 $d_i = Hash_2（key）$时，称为双散列法，需要两个散列函数。第一个发生冲突时，可利用第二个散列函数计算增量：
>    $$
>    H_i=(H(Key)=i\times Hash_2(key))\%m
>    $$
>    
>
> 4. **伪随机法**
>    当$d_i$ =伪随机数列时，称为为随机法

##### **2. 拉链法**

以顺序表为例，我们用除留余数法时很明显我们在下面1-9的存储单元中如果放入1和11的话会发生冲突，这时我们把1和11构成一个链表，把表头放在1的位置。这就是拉链法。把发生冲突位置的关键字构成一个链表放入存储单元



#### 散列查找及性能分析

> 散列表查找与散列表构造步骤基本一致，对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：
> 初始化：$Addr = Hash（key）$
>
> 1. 检测查找表中地址为Addr的位置上是否有记录，若无记录，返回**查找失败**；若有记录，比较它的与key的值，若相等则返回**查找成功**，否则执行步骤2
> 2. 用给定的处理冲突方法计算下一个散列地址，并把Addr置为此地址，转为步骤1
>
> 以下表为例计算ASL:
>
> | 关键字   | 14   | 01   | 68   | 27   | 55   | 19   | 20   | 84   | 79   | 23   | 11   | 10   |
> | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | 比较次数 | 1    | 2    | 1    | 4    | 3    | 1    | 1    | 3    | 9    | 1    | 1    | 3    |
>
> $ ASL = （1\times6+2+3\times3+4+9）/12 = 2.5$
>
> 从散列表的查找过程可见：
>
> 1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于**冲突**的存在使得散列表仍然是一个基于比较的过程。因此仍需要以平均查找长度作为衡量散列表的查找效率的度量。
> 2. 散列表的查找效率取决于三个因素：**散列函数、处理冲突的方法和装填因子**
>    **装填因子**：定义为一个表的装满程度$a = \frac{表中记录数n}{散列表长度m}$
> 3. 散列表的平均查找长度仅依赖于散列表的装填因子$a$，不依赖于处理冲突的方法与散列函数。



## 排序算法

### 排序算法代码

#### 1、冒泡排序

```java
public static void bubbleSort（int[] arr） {
    int n = arr.length;
    for （int i = 0; i < n - 1; i++） {
        for （int j = 0; j < n - i - 1; j++） {
            if （arr[j] > arr[j + 1]） {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

#### 2、选择排序

```java
void selectionSort（int[] arr） {
    int n = arr.length;
    for （int i = 0; i < n - 1; i++） {
        int minIndex = i;
        for （int j = i + 1; j < n; j++） {
            if （arr[j] < arr[minIndex]） {
                minIndex = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

#### 3、插入排序

```java
public void insertionSort（int[] arr） {
    int n = arr.length;
    for （int i = 1; i < n; i++） {
        int key = arr[i];
        int j = i - 1;
        while （j >= 0 && arr[j] > key） {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

#### 4、快速排序

```java
    public void quickSort（int[] nums, int left, int right） {
        if （left >= right） {
            return;
        }
        // 快排优化：随机让数组中的一个元素与 nums[left] 交换
        int pivot = nums[left];
        int i = left;
        int j = right;
        while（i < j） {
            while （i < j && nums[j] >= pivot） {
                --j;
            }
            while（i < j && nums[i] <= pivot） {
                ++i;
            }
            if （i < j） {
                swap（nums, i, j）;
            }
        }
        swap（nums, left, i）;
        quickSort（nums, left, i - 1）;
        quickSort（nums, i + 1, right）;
    }
```

#### 5、归并排序

```java
public static void mergeSort（int[] arr, int left, int right） {
    if （left < right） {
        int mid = （left + right） / 2;
        mergeSort（arr, left, mid）;
        mergeSort（arr, mid + 1, right）;
        merge（arr, left, mid, right）;
    }
}

public static void merge（int[] arr, int left, int mid, int right） {
    int[] temp = new int[right - left + 1];
    int i = left;
    int j = mid + 1;
    int k = 0;
    while （i <= mid && j <= right） {
        if （arr[i] <= arr[j]） {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    while （i <= mid） {
        temp[k++] = arr[i++];
    }
    while （j <= right） {
        temp[k++] = arr[j++];
    }
    for （int p = 0; p < temp.length; p++） {
        arr[left + p] = temp[p];
    }
}

```

#### 6、堆排序

```java
public void heapSort（int[] arr） {
    int n = arr.length;

    // 构建大顶堆，如果 1 为开始下标，则 i = n / 2
    for （int i = n / 2 - 1; i >= 0; i--） {
        heapify（arr, n, i）;
    }

    // 依次取出堆顶元素，放到末尾
    for （int i = n - 1; i > 0; i--） {
        // 将堆顶元素交换到末尾
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // 对剩余元素进行堆化，重新构建大顶堆
        heapify（arr, i, 0）;
    }
}

/**
 * 对以指定节点为根节点的子树进行堆化，使其满足大顶堆的性质
 * 
 * @param arr  待排序数组
 * @param n    堆的大小，需要堆化的元素个数
 * @param root 要堆化的子树的根节点
 */
private void heapify（int[] arr, int n, int root） {
    int largest = root; // 记录根节点、左子节点、右子节点中的最大值
     // 如果从 1 开始：left = root << 1; right = root << 1 | 1;
    int left = 2 * root + 1;
    int right = 2 * root + 2;

    // 找出左子节点、右子节点、根节点中的最大值
    if （left < n && arr[left] > arr[largest]） {
        largest = left;
    }
    if （right < n && arr[right] > arr[largest]） {
        largest = right;
    }

    // 如果根节点不是最大值，则将根节点和最大值交换，并递归对子树进行堆化
    if （largest != root） {
        int temp = arr[root];
        arr[root] = arr[largest];
        arr[largest] = temp;
        heapify（arr, n, largest）;
    }
}
```

建堆时间复杂度：

- 自顶向下建法：O（nlogn）
- 自底向上建法：O（n）

### 排序算法时间复杂度

![image-20230219153340032]（https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230219153340032.png） 

> ##### 特殊情况处理：
>
> - **对于大量的浮点数进行排序**：优先考虑使用快速排序算法，因为快速排序算法的时间复杂度为 O（nlogn），而且实际表现通常很好，在大多数情况下优于其他基于比较的排序算法。
> - **对于已经排好序的数组**：使用插入排序、冒泡排序算法的时间复杂度是 O（n）。
> - **对于只包含0和1的数组**：可以使用桶排序算法来对其进行排序，桶排序的时间复杂度为 O（n）。
> - **对于1亿个数据数组选出前100大的数**：使用堆排序，建立一个100大小的数组读出前100个数据，建立小顶堆，随后依次读入数据。若读入的数据小于堆顶的数则丢弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕。
>   假设选出前 K 大的元素，从 n 个数据中选出：
>   - 时间复杂度：建堆：O（K）		调整1次：O（log K） 		调整n次：O（nlogK ） $\approx$ O（n）
>   - 空间复杂度：O（K） $\approx$  O（1）
>
>

# 其他

## 数据库

### 什么是数据库中的基本表，什么是视图，两者有什么关联

> 答：基本表是本身独立存在的表，在**SQL中一个关系就对应一个表**。
>
> 视图是从一个或几个基本表（或视图）导出的表。视图本身不存在独立存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍然存放在原来的基本表中。
>
> 联系：视图中的数据来源于基本表，都可以进行查询，基本表中的数据发生变化，从视图中查询出的数据也就随之改变。
>
> 区别：基本表中存储实际的数据，而视图只存储定义，不存放实际数据，就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。

## 密码学

### 对称加密和非对称加密区别

> 对称加密使用同一个密钥进行加密和解密。发送方使用密钥对明文进行加密，接收方使用相同的密钥对密文进行解密。对称加密的优点是加密和解密速度快，适合对大量数据进行加密和解密。常用的对称加密算法有DES、3DES、AES等。
>
> 非对称加密则使用一对密钥，分别是公钥和私钥。公钥可以公开给任何人使用，私钥只有密钥拥有者才能使用。发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密。非对称加密的优点是安全性高，因为即使公钥被泄露，也无法解密密文。常用的非对称加密算法有RSA、DSA等。

## 名词解释

### 大数据（big data）

> 大数据是指以传统数据处理方法无法处理的海量数据集合。这些数据集合往往具有高度的复杂性、多样性和实时性，需要通过新的技术手段进行采集、存储、管理、分析和应用。大数据技术包括分布式存储、分布式计算、数据挖掘、机器学习、人工智能等多种技术手段，可以帮助人们更好地理解和利用数据，从而支持各种应用场景，例如金融、医疗、智能交通、智能制造等。

### 人工智能（AI）

> 人工智能（Artificial Intelligence，AI）指的是计算机程序和机器的能力，能够模拟人类的智能行为，如学习、推理、问题解决和自然语言理解等。

### 云计算

> 云计算是一种通过网络提供计算资源和服务的方式，这些资源和服务包括计算能力、存储空间、应用程序和数据。这些资源通常是由多台服务器组成的大型数据中心提供的，用户可以通过互联网从中获取所需的计算资源和服务。

### 应用程序编程接口（API）

> 是一种计算接口，它定义多个软件中介之间的交互，以及可以进行的调用（call）或请求（request）的种类，如何进行调用或发出请求，应使用的数据格式，应遵循的惯例等。

### COCOMO

> COCOMO模型根据软件代码行数、人月数等因素，估算软件开发所需的时间和成本。

### Git 分布式版本控制软件

> git是一个分布式版本控制软件。最初目的是为了更好地管理Linux内核开发而设计。

### SVN 集中式版本控制软件

> Subversion（SVN） 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库（repository） 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。

## 问答题

### 算法分析是什么，解决什么问题的

> 算法分析是指对计算机算法的性能和效率进行评估和优化的过程。它的目的是了解算法在输入数据不断增加的情况下，其运行时间和空间需求如何变化，并找出可能的瓶颈和改进方案。

### has a 和 is a 的区别

> "has a"和"is a"是面向对象编程中两个重要的概念，它们的区别如下：
>
> 1. "has a"表示一个对象包含另一个对象，即一个类的实例对象包含了另一个类的实例对象。例如，一个汽车对象"has a"引擎对象，因为汽车包含了一个引擎。
> 2. "is a"表示一个对象是另一个对象的一种类型，即一个类的实例对象是另一个类的实例对象。例如，一个猫对象"is a"动物对象，因为猫是动物的一种。
>
> 总体来说，"has a"表示对象之间的组合关系，而"is a"表示对象之间的继承关系。使用"has a"可以实现对象之间的组合和协作，而使用"is a"可以实现对象之间的继承和多态。在面向对象编程中，选择使用"has a"还是"is a"关系要根据具体的需求来确定。

## Java

### Volatile修饰符

> 在Java语言中，`volatile`是一种关键字，用于修饰变量。它的作用是保证该变量对所有线程的可见性，并禁止对该变量进行重排序。
>
> 具体来说，使用`volatile`修饰的变量，在**写入值时会立即刷新到主内存中，并且在读取该变量时会从主内存中获取最新的值，而不是从线程的本地缓存中获取**。这样可以确保在多线程并发的情况下，所有线程都能够看到该变量的最新值，避免了数据不一致的问题。
>
> 另外，`volatile`修饰符还可以**防止指令重排优化**。在不使用`volatile`修饰符的情况下，为了提高程序的执行效率，JVM可能会对指令进行重排序。但是这种重排序可能会导致程序的行为出现不可预测的问题。使用`volatile`修饰符可以告诉JVM不要对该变量进行重排序。
>
> 需要注意的是，`volatile`修饰符不能保证原子性，如果多个线程同时对同一个`volatile`变量进行修改，可能会出现竞态条件的问题。在需要保证原子性的情况下，需要使用`synchronized`关键字或者`java.util.concurrent.atomic`包中提供的原子类来保证线程安全。

### lock和semaphore分别实现互斥访问，并且不无限等待

1. `Lock`实现互斥访问，并且不无限等待的示例代码：

```java
Lock lock = new ReentrantLock（）;
boolean locked = lock.tryLock（100, TimeUnit.MILLISECONDS）;
try {
    if （locked） {
        // 访问共享资源
    } else {
        // 获取锁失败
    }
} finally {
    if （locked） {
        lock.unlock（）;
    }
}
```

在这个示例代码中，我们使用`tryLock（）`方法尝试获取锁，如果在给定的等待时间内获取到了锁，就执行共享资源的访问操作，如果获取锁失败，则执行获取锁失败的操作。通过这种方式，我们可以避免线程无限等待的问题。

1. `Semaphore`实现互斥访问，并且不无限等待的示例代码：

```java
Semaphore semaphore = new Semaphore（1）;
try {
    if （semaphore.tryAcquire（100, TimeUnit.MILLISECONDS）） {
        // 访问共享资源
    } else {
        // 获取锁失败
    }
} catch （InterruptedException e） {
    // 处理异常
} finally {
    semaphore.release（）;
}
```

### 接口与抽象类的区别

> **相同点：**
>
> （1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。
>
> **不同点：**
>
> （1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
>
> （2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
>
> （3）接口强调特定功能的实现，而抽象类强调所属关系。
>
> （4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。

































































































