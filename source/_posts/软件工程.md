---
title: 软件工程
date: 2023-03-18 00:00:00
tags: 
categories: 考研复试
keywords:
description:
top_image:
comments:
cover: https://w.wallhaven.cc/full/y8/wallhaven-y8622k.jpg
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---
<meta name="referrer" content="no-referrer"/>



# 软件工程概述

## 软件危机

### 1 什么是软件危机

> **定义**：计算机软件的**<font color='red'>开发</font>**和**<font color='red'>维护</font>**过程所遇到的一系列严重问题。
>
> **表现**：
> （1）对软件开发成本和进度的估算很不准确
> （2）用户很不满意
> （3）质量很不可靠
> （4）没有适当的文档难于维护
> （5）软件成本比重上升
> （6）供不应求：软件开发生产率跟不上计算机应用迅速深入的趋势

### 2 软件危机的原因

> **客观**：软件本身独有的特点确实给开发和维护带来了困难 Ps：逻辑部件、规模庞大、维护数量不断膨胀（软件维护通常意味着改正或修改原来的设计）
>
> **主观**：与软件开发和维护的许多错误认识和做法的形成有关
> Ps：忽视需求分析、认为软件开发=程序编写、轻视软件维护

### 3 如何解决软件危机

> **组织管理**
> 用现代工程的概念，原理，技术和方法进行计算机软件的开发，管理和维护
> （编写程序所需的工作量只占软件开发全部工作量的10%～20%）
> 做好软件定义时期的工作
>
> **技术措施**
> 软件开发技术与方法（例如面向对象技术等）
> 软件工具（例如配置管理工具、测试工具等）

## 软件工程

### 1 软件工程的概念

软件工程（Software Engining）是指导计算机软件开发和维护的一门学科，采用工程的概念、原理、技术和方法来开发与维护软件。

### 2 软件工程要素、目标和原则

> 软件工程三要素：方法、工具和过程。
>
> - 方法：提供了“如何做”的技术
> - 工具：提供了自动或半自动的软件支撑环境
> - 过程：将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的
>
> 软件工程的目标可概括为：通过系统化、规范化的方式，将计算机科学的原理、方法和工具应用于软件的开发、维护和演化中，以提高软件开发的效率、质量和可靠性。
> 软件工程的最终目的是摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。

### 3 软件质量定义

软件质量是软件特性的综合，指**软件与明确的和隐含地定义的需求相一致的程度**。

### 4 软件质量的评测

> 通过以下四个方面进行评估
> **可靠性**：正确性和健壮
> 正确性和对异常值边界值的处理能力
> **可维护性**
> 可读性，可修改性，可测试性，完整性
> **可理解性**
> 简单性，清晰性，可用性
> **效率**

## 软件过程

### 1 瀑布模型

> 软件过程：为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。

#### 1.1 定义

**瀑布模型**（Waterfall Model）是一种软件开发生命周期模型，它是最早提出的一种软件开发过程模型，由Winston Royce于1970年提出。**<font color='red'>瀑布模型将软件开发过程划分为多个阶段，每个阶段的结果都是下一个阶段的输入，严格按照流程进行，每个阶段的输出作为下一个阶段的输入。</font>**因此，瀑布模型也被称为“经典生命周期模型”。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304153502690.png" alt="image-20230304153502690" style="zoom:67%;" />



瀑布模型的基本流程，包括需求**分析、设计、编码、测试和维护**等几个阶段，每个阶段的输出作为下一个阶段的输入，从而构成了一个线性的开发流程。

#### 1.2 瀑布模型的特征

| 特点       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 阶段划分   | 将软件开发过程划分为需求分析、设计、编码、测试和运行维护等几个阶段，每个阶段都有特定的目标和输出。 |
| 线性流程   | 每个阶段严格按照顺序进行，下个阶段必须等待上个阶段结束，上一个阶段的输出是下一个阶段的输入。 |
| 阶段交付物 | 每个阶段都有特定的交付物，比如需求文档、设计文档、编码实现等，这些交付物都需要经过审核、验收等过程。 |
| 难以回溯   | 由于每个阶段都是线性的，因此难以回溯到前面的阶段进行修改和调整，容易导致重复工作和浪费时间和资源。 |

#### 1.3 瀑布模型的优缺点

- **优点**：瀑布模型适用于需求明确、稳定性高的软件开发项目，例如传统的信息系统开发。
- **缺点**：
  - 由于其线性流程的特点，因此在开发初期需要花费大量的时间和精力进行前期规划和需求分析，如果需求变更频繁，则会导致项目延期和成本增加。
  - 由于瀑布模型难以回溯，因此需要对需求和设计进行充分的讨论和确认，以避免后期修改和调整。

---

### 2 快速原型模型

#### 2.1 定义

**快速原型模型**是一种软件开发模型，其主要思想是**<font color='red'>快速构建一个可用的“软件原型”，并根据用户的反馈和需求逐步完善和改进软件。</font>**快速原型模型通常用于需求不明确或难以准确定义的项目，以及需要快速验证软件可行性和功能性的项目。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/827c6ce3e63649bca2f0df30a621d827.png" referrerpolicy="no-referrer" alt="在这里插入图片描述">

> ps：图中的实线为开发过程，虚线为软件维护过程

#### 2.2 快速原型模型的特征

| 特征     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 快速性   | 快速原型模型的主要特点是能够快速开发出可行的原型，并进行测试和评估。它不仅能够节省时间和成本，还能够提高项目的成功率。 |
| 用户参与 | 快速原型模型强调用户的参与和反馈，能够帮助团队更好地理解用户需求，从而开发出更符合用户需求的产品。 |
| 迭代性   | 快速原型模型是一个迭代的过程，软件产品一旦交付给用户使用后，维护便开始了。 |
| 灵活性   | 快速原型模型比传统的瀑布模型更加灵活，能够根据实际情况进行调整和改变，从而更好地适应项目的需求和变化。 |

---

### 3 增量模型

#### 3.1 定义

**增量模型**是一种软件开发过程模型，<font color='red'>**它将软件系统分成多个独立的功能模块，并采用逐步添加新的功能模块的方式进行开发**</font>。在增量模型中，每个增量都是一个完整的软件系统，它包含了新增的功能模块以及之前已经开发完成的模块，从而分批次地分析、设计、编码和测试这些增量组件。

增量模型的第一个增量模块往往实现软件的基本需求，提供最核心的功能。

![image-20230303212149564](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230303212149564.png)

#### 3.2 增量模型特征

| 特征                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 分阶段开发             | 采用分阶段开发方法，将整个软件开发过程分为多个阶段，每个阶段的开发成果都可以被使用和测试 |
| 每个增量都是完整的系统 | 每个增量包含了一个或多个功能模块，可以独立运行，是一个完整的系统 |
| 模块化                 | 增量模型采用模块化设计，可以让开发人员对系统进行分解，每个模块都可以独立地进行开发和测试 |
| 迭代式开发             | 每个增量都可以看做是一个迭代，开发人员可以根据需求逐步添加新的功能，完善系统 |
| 风险控制               | 增量模型采用了风险控制的方法，每个增量都是一个可测试的产品，可以及时发现和解决问题 |

#### 3.3 增量模型的优缺点

- 优点：
  - 自第一个构件交付起，用户便可使用软件做一定量的工作，能够向用户在较短时间内提供可完成部分工作的产品是增量模型的优点。
  - 逐步增加产品功能有助于用户更好地适应软件。
- 缺点：没一个新增的构件加入到系统中，之前已经加入的构件均不能被修改，这必须把软件结构设计地便于按这种方式进行扩充，增加了开发难度。

---

### 4 螺旋模型

#### 4.1 定义

螺旋模型是一种风险驱动的软件开发过程模型，在项目开发过程中，风险无处不在，项目越大，软件越复杂，承担该项目的风险也就越大。在快速原型模型中曾提到了“软件原型”的概念，而螺旋模型的基本思想，就是使用原型以及其他方法来降低风险，**可以将其视为每一个阶段之前都添加风险分析过程的快速原型模型**。

每次迭代中都会包含计划、风险分析、工程实现和评审四个阶段，每个迭代周期结束后都会进行回顾和评估，并在此基础上制定下一轮的计划。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20191213122139497.png" alt="在这里插入图片描述" style="zoom: 44%;" />

#### 4.2 螺旋模型的优缺点

优点：

- 强调风险管理，能够减少项目失败的风险。
- 适用于大规模、复杂、安全性要求高的软件开发。
- 建立在早期原型开发和增量式开发的基础上，能够更好地满足客户的需求。

缺点：

- 适用范围相对较窄，不适合小规模的软件开发。
- 需要更多的风险评估和管理，对项目管理能力要求高。
- 开发成本相对较高。

----

### 5 喷泉模型

#### 5.1 定义

喷泉模型（fountain model）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。各个阶段使用统一的概念和表示方法，生命周期各阶段无缝连接（面向对象方法在概念和表示方法上的一致性，保证了各项开发活动之间的无缝连接)。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/d2ac5c4eff44410ea75d9ba20b7a2dc5.jpeg" alt="img" style="zoom:50%;" />

#### 5.2 喷泉模型的优缺点

**优点：**

- 喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发可以提高软件项目开发效率，节省开发时间适应于面向对象的软件开发过程。

**缺点：**

- 由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，因此不利于项目的管理。
- 喷泉模型要求严格管理文档，使得审核的难度加大尤其是面对可能随时加入的各种信息、需求与资料的情况。

#### 5.3 适用场景

面向对象开发

### 6 敏捷过程

敏捷过程由下面 4 个简单的价值观声明而成：

1. 个体和交互胜过过程和工具
2. 可以工作的软件胜过了面面俱到的文档
3. 客户合作胜过合同谈判
4. 响应变化胜过遵循计划

### 7 极限编程

极限编程之所以能在采用它的企业中获得成功，是因为它高度强调客户满意。这种方法并不尝试一次交付所有可能在遥远的将来用到的功能，而是在真正需要时交付最有价值的软件。极限编程使软件开发者满怀信心地响应客户的需求变化，哪怕在交付项目的后期也同样如此。

极限编程强调团队协作。在一支高度协同的团队中，管理者、客户、开发者都是平等的合作伙伴。极限编程营造了简单而有效的协作环境，使团队最大程度地发挥其生产力。团队自发地组织起来，尽可能高效地解决问题。

**极限编程从五个方面提升软件项目：沟通、简单、反馈、尊重、勇气**

- 实践极限编程的程序员持续不断地与客户和其他程序员**沟通**。
- 他们保持设计**简单**整洁。
- 他们从项目第一天起就对软件做测试，从测试中获得**反馈**。
- 他们尽可能早把系统交付给客户使用，**尊重**客户提出修改意见的权利。
- 他们小步前进，每一次小的成功都会增进团队成员彼此之间的**尊重**与信任。
- 在前面这些的基础上，极限编程的实践者们方有**勇气**积极响应不断变化的需求和技术。

# 可行性研究

## 1 可行性研究的目的

可行性研究的目的就是<font color='red'>用最小的代价在尽可能短的时间内确定问题是否能够解决</font>。必须分析几种解法的利弊，从而判断原定的系统目标和规模是否现实，系统完成后所能带来的效益是否大到值得投资开发这个系统的程度。

一般说来，至少应该从以下三个方面研究每种解法的可行性：

- **技术可行性**：使用现有的技术能否实现这个系统

- **经济可行性**：这个系统的经济效益能否超过它的开发成本

- **操作可行性**：这个系统的操作方式在客户组织内是否行得通。



## 2 系统流程图(SFD)

### 2.1 概念

**系统流程图（System Flowchart）：**是描绘系统物理模型的传统工具。它的基本思想是用图形符号以黑盒子形式描绘系统里面的每个部件(程序、文件、数据库、表格、人工过程等），表达信息在各个部件之间流动的情况和系统的操作控制。

### 2.2 系统流图符号定义

![img](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20190423090657322.png)

就机房收费系统为例，系统流程图如下：

![img](https://img-blog.csdnimg.cn/2019042309024470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjcyNDQ2Nw==,size_16,color_FFFFFF,t_70)

## 3 数据流图(DFD)

### 3.1 数据流图基本概念

**数据流图 (Data Flow Diagram，DFD)** 是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经历的变换。

**数据流图的优点**：

1. 在数据流图中没有任何具体的物理元素，它只是描绘信息在软件中流动和被处理的情况。
2. 因为数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，所以是分析员与用户之间极好的沟通工具。
3. 设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需考虑怎样具体地实现这些功能，因此，它也是今后进行软件设计很好的出发点。
4. 数据流图可以在任何抽象层次上被用来表示系统或软件。事实上，数据流图可以被分层次地画，层次越低（在数据流图中1层比0层的层次更等）表现出的信息流细节和功能细节也越多。数据流图既提供了功能建模机制、也提供了信息流建模机制

### 3.2 数据流图的基本符号

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304165426558.png" alt="image-20230304165426558" style="zoom:60%;" /><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304170305326.png" alt="image-20230304170305326" style="zoom: 50%;" />

数据流图有4种基本符号：

- 正方形（或立方体）表示数据的源点或终点；
- 圆角矩形（或圆形）代表变换数据的处理；
- 开口矩形（或两条平行横线）代表数据存储；
- 箭头表示数据流，即特定数据的流动方向。

### 3.3 数据流图案例

#### 示例1：工厂订单报表

假设一家工厂的<font color='orange'>采购部</font>每天需要一张<font color='green'>订货报表</font>，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据:零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为<font color='green'>事务</font>，通过放在<font color='orange'>仓库</font>中的CRT终端把事务报告给<font color='red'>订货系统</font>。当某种零件的库存数量少于库存量临界值时就应该再次订货。

------

##### 数据流图有4种成分分析

**数据流图有4种成分：源点和终点、处理、数据存储和数据流。画出上述定货系统的数据流图可采用以下步骤。**

1. **首先考虑数据的源点和终点**，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的终端把事务报告给订货系统”，所以**采购员是数据终点，而仓库管理员是数据源点**。
2. **接下来考虑处理**。再一次阅读问题描述，“采购部需要报表”，显然他们还没有这种报表，因此必须有一个用于**产生报表的处理**。事务的后果是改变零件库存量，而任何改变数据的操作都是处理，因此，**对事务进行的加工是另一个处理**。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。
3. **最后考虑数据流和数据存储**。系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配：每当有一个事务发生时立即处理它，然而每天只产生一次订货报表，因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储（存储着订货报表的数据，每当订货报表的数据有更新时，可以立即获取最新的订货报表的数据，这样就可以实现每当有一个事务发生时立即处理它）。

**注意，并不是所有数据存储和数据流都能直接从问题描述中提取出来。例如，“当某种零件的库存数量少于库存量临界值时就应该再次订货”，这个事实意味着必须在某个地方有零件库存量和库存量临界值这样的数据。因为这些数据元素的存在时间看来应该比单个事务的存在时间长，所以认为有一个数据存储保存库存清单数据是合理的。**

下表列出了上面分析的结果，其中加星号标记的是在问题描述中隐含的成分。

![在这里插入图片描述](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/046af817fbf24923a43b2d557a5336f7.png)

------

##### 开始画数据流图

一旦把数据流图的4种成分分离出来后，就可以着手画数据流图了。但是要注意，数据流图是系统的逻辑模型，而任何计算机系统实质上都是信息处理系统，也就是说计算机系统本质上都是把输入数据变换成输出数据。因此，任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能。

------

###### 顶层数据流图

对于上述的定货系统可以画出下图所示的顶层数据流图（**突出表明了数据的源点和终点**）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3ba3eb7c6f744b85b9f21bdfd5adb35f.png)
从**顶层数据流图**这样非常高的抽象层次开始画数据流图是一个好办法。在这个高层次的数据流图上是否列出了所有给定的数据源点 / 终点是一目了然的，因此它是很有价值的沟通工具。

------

###### 第0层数据流图

**顶层数据流图**太抽象了，从这张图上所能了解到的信息非常有限。**下一步应该把基本系统模型细化，描绘系统的主要功能。**

由于 “产生报表” 和 “处理事务” 是该系统必须完成的两个主要功能，它们将代替图顶层数据流图中的“订货系统”。此外，细化后的数据流图中还增加了两个数据存储：处理事务需要“库存清单”数据；产生报表和处理事务在不同时间，因此需要存储“定货信息”。除了2.1节（2.1 数据流图有4种成分分析）的表中列出的两个数据流之外还有另外两个数据流，它们与数据存储相同。这是因为从一个数据存储中取出来的或放进去的数据通常和原来存储的数据相同，也就是说，数据存储和数据流只不过是同样数据的两种不同形式（事务 <–> 库存清单，订货信息 <–> 订货报表）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a2052e7924284f6bb1b9bcbfe0d47318.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

给处理和数据存储都加了编号，这样做的目的是便于引用和追踪。

------

###### 第1层数据流图

接下来应该对功能级数据流图中描绘的系统主要功能进一步细化。考虑通过系统的逻辑数据流，当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。因此，把“处理事务”这个功能分解为下述3个步骤：“接收事务”、“更新库存清单”和“处理订货”，这在逻辑上是合理的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f99b95acfa87410b8dd19b99b7baffc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

我们为什么不进一步分解“产生报表”这个功能呢？因为订货报表中需要的数据在存储的订货信息中全都有，产生报表只不过是按一定顺序排列这些信息，再按一定格式打印出来。然而这些考虑纯属具体实现的细节，不应该在数据流图中表现。同样道理，对“接收事务”或“更新库存清单”等功能也没有必要进一步细化。**总之，当进一步分解将涉及如何具体地实现一个功能时，就不应该再分解了。**

在对数据流图分层细化时必须保持信息连续性，即当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。

还应该注意在数据流图中对处理进行编号的方法。处理1.1，1.2和1.3是更高层次的数据流图中处理1的组成元素。如果处理2被进一步分解，它的组成元素的编号将是2.1， 2.2……如果把处理1.1进一步分解，则将得到编号为1.1.1，1.1.2……的处理，以此类推。

------

##### 补充: 数据流图命名规范

数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。
因此，给这些成分起名字时应该仔细推敲。

数据源点/终点并不需要在开发目标系统的过程中设计和实现，它并不属于数据流图的核心内容，只不过是目标系统的外围环境部分（可能是人员、计算机外部设备或传感器装置）。通常，为数据源点 / 终点命名时采用它们在问题域中习惯使用的名字（如“采购员”、“仓库管理员”等）。

> 数据流（或数据存储）命名：

- 名字应代表整个数据流（或数据存储）的内容，而不是仅仅反映它的某些成分。
- 不要使用空洞的、缺乏具体含义的名字（如“数据”、“信息”、“输入”之类）。
- 如果在为某个数据流（或数据存储）起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。

> 处理命名：

- 通常先为数据流命名，然后再为与之相关联的处理命名。这样命名比较容易，而且体现了人类习惯的“由表及里”的思考过程。
- 名字应该反映整个处理的功能，而不是它的一部分功能。
- 名字最好由一个具体的及物动词加上一个具体的宾语组成。应该尽量避免使用“加工”、“处理”等空洞笼统的动词作为名字。
- 通常名字中仅包括一个动词。如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。
- 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。

------

#### 练习1：教务管理子系统

教务管理是一项需求周密计划、严谨安排的工作，要依据教师、学生信息进行合理安排。

> 教务管理子系统的需求描述：

- 开学阶段，需要<font color='orange'>教师</font>提交开课<font color='green'>申请进行开课</font>，<font color='orange'>学生</font>根据老师的开课信息，选择课程，教务处生成学生课表、教师课表。
- 期末阶段，需要根据开课情况对学生进行<font color='green'>考试安排</font>，对教师进行监考安排，以及学生考试成绩管理。
- 学期结束，需要对学生<font color='green'>成绩进行统计</font>，计算绩点，排名，评定奖学金。

------

##### 3.1.1 顶层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/b693d6634fd64aa0818998909107e3b8.png)

------

##### 3.1.2 第0层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/ee6a029c391942eb9fc7ecfd068f450b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

##### 3.1.3 第1层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/fbc808338f7a4d82aea313ec8ed66199.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

#### 练习2：图书馆管理子系统

> 图书馆管理子系统的需求描述：

- 借书过程，学生到图书馆查询图书信息，出示借书证，办理借书。
- 还书过程，判断是否超期、图书是否破损，办理还书。

------

##### 3.2.1 顶层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/54860f267be143d89fd82576ad269695.png)

------

##### 3.2.2 第0层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/64977ac1055b421a9d8f279bf14fef20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

##### 3.2.3 第1层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/8c804676bdae447b93e038c9131b266f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

### 3.4. 补充：数据流图的附加符号

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec85e3bc664f4ac4a46c79370b9d27e7.png)

- `*` 表示数据流之间是“**与**”关系（同时存在）
- `+` 表示“**或**”关系
- ⊕ 号表示只能从中选一个（互斥的关系）

注意：这里的圆形可以被圆角矩形框替换，都表示变换数据的处理。
![在这里插入图片描述](https://img-blog.csdnimg.cn/dbca1c655f3a46378595c4aac37f8f26.png)

------

### 3.5. 说明：顶层数据流图和0层的关系

![在这里插入图片描述](https://img-blog.csdnimg.cn/2760f84930c74d7da4c70f70fc5d0579.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/35b86392754745c391922b2fcf973114.png)

- **顶层数据流图只含一个加工表示整个系统**
- **0层数据流图是对父层数据流图中某个加工进行细化，它的某个加工也可以再次细化，形成子图，层次的多少，一般视系统的复杂程度而定。**

## 4 数据字典

数据字典的定义：**数据字典是关于数据的信息的集合，也就是对数据流图中所包含的所有元素的定义的集合。**

定义组成包含：**数据流、数据流分量（即数据元素）、数据存储、处理**

如何定义数据的方法：对数据自顶向下分解 

数据字典的用途：

1. **作为分析阶段的工具。**
2. **数据字典中包含的每个数据元素的控制信息是很有价值的。**
3. **数据字典是开发数据库的第一步，是很有价值的一步。**

## 5 成本和效益分析

### 5.1 成本估计技术

1. **代码行技术** 
2. **任务分解技术** 
3. **自动估计成本技术**

### 5.2 成本效益分析方法

1. **货币的时间价值** 
2. **投资回收期** 
3. **纯收入** 
4. **投资回收率**

# 需求分析

## 1 需求分析概述

### 1.1 什么是需求分析

- 需求分析是指开发人员要准确地理解用户的要求，进行细致的调查研究，将用户非形式化的需求描述转化为完整的需求定义，再由需求定义转化为相应的**软件需求规格说明书**（即需求分析的结果）的过程。
- 需求分析是理解、分析和表达“系统必须做什么”的过程。
- 需求分析是为用户所看到的系统建立一个概念模型，是对需求的抽象描述。

### 1.2 需求分析的基本任务

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/f55749784aea4f0ea2e5b3de7ad6db6f.png" alt="在这里插入图片描述" style="zoom: 25%;" />

- 收集需求：对用户需求进行收集整理；
- 分析需求：对需求进行分析，挖掘用户真实需求；
- 需求评估：筛选过滤掉不可行的需求；
- 需求设计：针对用户需求提出解决方案，设计成产品方案；
- 验证需求：验证方案是否可行。

## 2 分析建模

### 2.1 什么是模型

**模型：**就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。通常，模型由一组图形符号和组织这些符号的规则组成。

### 2.2 （E-R）实体-联系图

#### 2.2.1 E-R 图的概念

E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型**。它属于数据库设计中概念结构设计的一部分，反映了用户需求。**

- 实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象。
- 属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性。属性分为唯一属性（键）与其他，唯一属性（键）就好比学生id,其他则是年龄、性别等不能唯一表示实体的属性。
- 联系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系。

#### 2.2.2 实体间的联系分类

- 1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系。 如，一个学校只有一个正校长。
- 1对多（1:N）
  ：1对多关系是指实体集A与实体集B中至少有N(N>0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。
  如多个学生选修同一门专业，则专业与学生关系则是1对多。
- 多对多（M:N） ：对于两个实体集A和B，若A中每一个实体值在B中有多个实体值与之对应，反之亦然，则称实体集A与实体集B具有多对多联系。
  如一个部门有多个员工，一个员工也可在多个部门任职。因此，员工与部门的工作关系为多对多。

#### 2.2.3 ER图表现形式

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230305105748624.png" alt="image-20230305105748624" style="zoom: 67%;" />

- 矩形框：表示实体，填入实体名
- 菱形框：表示联系，填入联系名，联系连接两个实体，联系的出入两边填入实体间的联系。
- 椭圆形框：表示实体或联系的属性，框内填入属性名。对于主属性名，如id，在其下方画下划线
- 连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。如

#### 2.2.4 ER图举例

一个学生可选修多门课，一门课有若干学生选修；
一个教师可讲授多门课，一门课只有一个教师讲授；
一个学生选修一门课，仅有一个成绩。
学生的属性有学号、学生姓名；教师的属性有教师编号，教师姓名；课程的属性有课程号、课程名。

**答案：**
<img src="https://img-blog.csdnimg.cn/00b7d5b1ea3e41938239e2cbe9af3c9c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA77mP6IG95rW3,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 80%;" />



## 3 数据规范化

### 3.1 第一范式

每个属性都是原子值，仅仅是个简单值不含内部结构，很好理解。

### 3.2 第二范式

在第一范式的基础上，所有的**非主属性完全依赖于主键，完全依赖意味着不能依赖于主键的一部分属性。**

反例：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215032997.png)
对于该表，学号和课程号组合在一起是主键，但是姓名只由学号决定，违反了第二范式。类似还有课程名由课程号决定。

所以应该拆分为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215110451.png)

### 3.3 第三范式

第三范式的条件：满足第二范式的基础上，**非主属性都不传递依赖于主键，即一个非关键字属性值不依赖于另一个非关键字属性。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215150687.png)
主键是学号，但是学校地址也可以由学校名称决定，存在传递依赖

分解为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215219145.png)

> **完全函数依赖**
>
> 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ’ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方，没办法打出来……，正确的写法如）
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201010151000478.png#pic_center)
>
> 例如： 学号 F→ 姓名 （学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）
>
> 
>
> **部分函数依赖**
>
> 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201010151118924.png#pic_center)
>
> 例如：（学号，课名） P→ 姓名
>
> 
>
> **传递函数依赖**
>
> 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X ，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020101015134156.png#pic_center)



## 4 状态转换图

状态转换图（[状态图](https://so.csdn.net/so/search?q=状态图&spm=1001.2101.3001.7020)）： 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。状态图还指明了作为特定事件的结果系统将做哪些动作，因此状态图提供了行为建模机制。

### 4.1 状态和事件

状态：状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个或一系列动作，也可以是仅仅改变系统本身的状态，还可以是即改变状态又做动作。    在状态图中定义的状态主要有：初态（初始状态）、终态（最终状态）、中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。

事件：事件是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另一个状态的外界事件的抽象。事件是引起系统做动作或（和）转换状态的控制信息

### 4.2 符号

​    ![img](https://img-blog.csdnimg.cn/2509d9f6df854c93ac91562f7e6ed09f.png)

### 4.3 举例

​    ![img](https://img-blog.csdnimg.cn/d72c4cf2c560441eaa55c53bd8e875b8.png)

## 5 验证软件需求

### 5.1 应该从哪些方面验证软件需求的正确性

1. **一致性**：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
2. **完整性**：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或 性能。
3. **现实性**：指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。对硬件技术的进步可以做些预测，对软件技术的进步则很难做出预测，只能从现有技术水平出发判断需求的现实性。
4. **有效性**：必须证明需求是正确有效的，确实能解决用户面对的问题。

# 总体设计

[这篇文章](https://blog.csdn.net/qq_42192693/article/details/109200817?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167808606916800182712654%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167808606916800182712654&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109200817-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1&spm=1018.2226.3001.4187)

## 启发规则

1，<font color='red'>**改进软件结构提高模块独立性**</font>：设计出软件的初步结构以后，应该审查分析这个结构，通过模块分解或合并，力求降低耦合提高内聚。

2，<font color='red'>**模块规模应该适中**</font>：一个模块的规模不应过大，最好能写在一页纸内(通常不超过60行语句)

3，<font color='red'>**深度、宽度、扇出和扇入都应适当**</font>

深度：软件结构中控制的层数
宽度：软件结构内同一个层次上的模块总数的最大值
扇出：一个模块直接控制(调用)的模块数目
扇入：一个模块被多少个上级模块直接调用的数目

4，<font color='red'>**模块的作用域应该在控制域之内**</font>

作用域：受该模块内一个判定影响的所有模块的集合。
控制域：模块本身以及所有直接或间接从属于它的模块的集合。

5，<font color='red'>**力争降低模块接口的复杂程度**</font>：模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。

6，<font color='red'>**设计单入口单出口的模块**</font>：这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。

7，<font color='red'>**模块功能应该可以预测**</font>：模块的功能应该能够预测，但也要防止模块功能过分局限。反例：模块使用全局变量或是静态变量，则可能导致不可预测。

# 详细设计

## 1 结构程序设计

### 1.1 结构程序设计的定义

结构程序设计是处理详细设计中采用的一种典型的方法，**所使用的结构由顺序、条件、重复3种控制结构进行连接。实现单入口、单出口，且无死循环、死语句的程序。**

### 1.2 五种基本控制结构

> 顺序型
>
> 选择型
>
> 先判定型循环（Do-While)
>
> 后判定型循环(Do-Until)
>
> 多情况选择型(CASE型）

![在这里插入图片描述](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20190601171635132.png)

---

## 2 过程设计工具

### 2.1 程序流程图

#### 2.1.1 程序流程图定义

> 程序流程图=程序流程+图

简单来说，就是**一种描述程序流向的图形**。一般由处理框、判断框、起止框、连接点、流程线、注释框等元素构成。

百度百科对它是这么定义的：

> 程序流程图又称程序框图，是用统一规定的标准符号描述程序运行具体步骤的图形表示。 程序框图的设计是在处理流程图的基础上，通过对输入输出数据和处理过程的详细分析，将计算机的主要运行步骤和内容标识出来。

#### 2.1.2 程序流程图的符号

以下是程序流程图常用的几个标准符号：

![img](https://img-blog.csdnimg.cn/img_convert/1b269a05f6f87cb0d6b39af1a9c9aa61.png)

- **循环的标准结构**

![img](https://img-blog.csdnimg.cn/img_convert/dc9578956a58fa73052567f481d7f87f.png)

- **注解符号的使用**

![img](https://img-blog.csdnimg.cn/img_convert/54dc82c59758c017d8d912fec964c0d5.png)

#### 2.1.3 程序流程图常见结构

**顺序型：**几个连续的处理步骤依次排列构成

![img](https://img-blog.csdnimg.cn/img_convert/a54b3bd6cfa3d1ca25c772f2c0c600cd.png)

**选择型：**由某个逻辑判断式的取值决定选择两个处理中的一个

![img](https://img-blog.csdnimg.cn/img_convert/3426a073beb7ac010fcbc0786c5adf15.png)

**先判定（while）型循环：**在循环控制条件成立时，重复执行特定的处理

![img](https://img-blog.csdnimg.cn/img_convert/c3cb9ce45c418e7631c43a24d70fe21e.png)

**后判定（until）型循环：**重复执行某些特定的处理，直至控制条件成立

![img](https://img-blog.csdnimg.cn/img_convert/5fe4a29d89f009772966a049ce74bc24.png)

**多情况（case）型选择：**列举多种处理情况，根据控制变量的取值，选择执行其一

![img](https://img-blog.csdnimg.cn/img_convert/de2c6a6412c304dfdce904367f5837bf.png)

### 2.2 盒图(N-S)

#### 2.2.1 顺序结构

所有语句顺序执行，先执行A后执行B

![img](https://img-blog.csdnimg.cn/img_convert/149e73f8deecc08c9376e8b123789f4c.png)

#### 2.2.2 选择结构

**1）条件结构**

如果条件P成立，执行A，否则执行B

![img](https://img-blog.csdnimg.cn/img_convert/4e141d97cabb204647f8dad50e16659b.png)

**2）多分支选择结构**

P=1的时候，执行A1，P=2的时候，执行A2，依次类推；

![img](https://img-blog.csdnimg.cn/img_convert/3eca3135d3f3bc8910f5ad07a737d224.png)

 

#### 2.2.3 循环结构

**1）当型循环结构**

先判断后执行，当P1条件成立的情况下，反复执行A语句，直到P1条件不成立为止

![img](https://img-blog.csdnimg.cn/img_convert/fcda6efaa39564deaafe7c85b2064214.png)

**2）直到型循环结构**

先执行后判断，当P1条件不成立的情况下，反复执行A语句，直到P1条件成立为止

![img](https://img-blog.csdnimg.cn/img_convert/87c6b119e663fc504219930b0a14bfd0.png)

### 2.3 PAD图

#### 2.3.1 PAD图基本符号

(a) 顺序；(b) 选择；(c) CASE多分支；(d) WHILE型循环； (e) Do-UNTIL型循环；(f) 语句标号；(g) 定义 

<img src="https://img-blog.csdnimg.cn/dde0d839c5e24163b11c072fe7546b43.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

#### 2.3.2 PAD图的应用

 1.请根据下列伪码画出对应的PAD图。

```cobol
GET(a[1],a[2],...a[10]);
max=a[1];
max2=a[2];
FOR i=2 TO 10
IF a[i]>max
max2=max;
max=a[i];
ELSE
IF a[i]>max2
max2=a[i]
ENDIF
ENDIF
ENDFOR
PUT(max,max2)
END
```

![img](https://img-blog.csdnimg.cn/0b59c226e6f94ac1aecfec938cde9648.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 2.请根据下列伪码画出对应的PAD图。

```cobol
定义变量:i=7,S=0
DO WHILE i<=1000
IF(i被7整除)
THEN
S=S+i
输出:i
ENDIF
i=i+1
ENDDO
输出:S
```

![img](https://img-blog.csdnimg.cn/caf5a6b631b54b578fadd45d9420d23a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 3.将下列N-S图转换为PAD图

![img](https://img-blog.csdnimg.cn/5f073eb390c3466f85f33155fd56148f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_7,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/7543940e159641bda3596290ed9d6835.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16) 4.将下列N-S图转换为PAD图

 ![img](https://img-blog.csdnimg.cn/faedd57142fc4ee39100359f3681d964.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_8,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/340e84facea1430a84f129c676b29d65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)



### 2.4 判定表与判定树

#### 2.4.1 判定表与判定树的概念

判定表与[判定树](https://so.csdn.net/so/search?q=判定树&spm=1001.2101.3001.7020)是一种列表设计工具，常用于条件嵌套的复杂判定情况的分析与设计，以及多分支结构代码的设计与实现。

（1）判定表

判定用来描述一些不易用语言表达清楚或需要很大篇幅才能用语言表达清楚的加工逻辑。在某些数据处理问题中，其数据流程图的处理需要依赖于多个逻辑条件的取值，这些取值的组合可能构成多种不同情况，相应地需要执行不同的动作。这种问题用结构化语言来叙述很不方便，使用判定表或判定树作为表示加工说明的工具是最合适的。 一个判定表由四个部分组成，如表5.1所示。

![img](https://img-blog.csdnimg.cn/184e04ab006d415c975f53742c51e2cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树      

判定树是用一种树图形方式来表示多个条件、多个取值所应采取的动作。判定树分支表示各种不同的条件，随着分支层次结构的扩充，各条件完成自身的取值。判定树的叶子给出应完成的动作。

#### 2.4.2 判定表与判定树的应用

细化学生成绩的奖励条件：学生每学期已修课程成绩的比率。优秀比率占70%以上，并且中以下所占比率小于15%，而且表现优良的学生可以获得一等[奖学金](https://so.csdn.net/so/search?q=奖学金&spm=1001.2101.3001.7020)，表现一般的学生可以获得二等奖学金；优秀比率占70%以上，中以下所占比率小于20%，表现优良的学生可以获得二等奖学金，表现一般的学生可以获得三等奖学金；中以下所占比率小于20%，表现优良的学生可以获得三等奖学金，表现一般的学生可以获得四等奖学金。请用判定表与判定树表达上述计算方案。

（1）判定表

![img](https://img-blog.csdnimg.cn/a22218eb3a854385b6922ee2e81f0b24.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树

![img](https://img-blog.csdnimg.cn/92c8172e26f84aa2afe531ddf956e559.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_14,color_FFFFFF,t_70,g_se,x_16) 

2.某校的课酬计算方案如下：(l)基本课酬为每节课10元；(2)如果班级人数超过40人，课酬增加：基本课酬×0.1；(3)如果班级人数超过60人，课酬增加：基本课酬×0.2；(4)如果教师是副教授，课酬增加：基本课酬×0.1；(5)如果教师是教授，课酬增加：基本课酬×0.2；(6)讲师，课酬不增加；(7)助教，课酬减少：基本课酬×0.1。请用判定表达上述计算方案。

![img](https://img-blog.csdnimg.cn/5ce6194afc9941e5b96b509df03997e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

3. 某高校研究生招生系统的初选方法如下：总分300（含）以上进入候选学生库，否则退档数学分数不低于70分，则进入三级备选库，否则进入四级备选库：在三级备选库的基础上，如果专业课分数高于100分，则进入一级备选库，否则进入二级备选库，请画出对应的判定表与判定树。

（1）判定表 

![img](https://img-blog.csdnimg.cn/b3abef7407904033a3d36555ab53932a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_18,color_FFFFFF,t_70,g_se,x_16)

（2）判定树![img](https://img-blog.csdnimg.cn/4934db126cf44c46a73b38eb070f6827.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

4.用判定表与判定树描述检查定货单的处理逻辑：“如果金额超过1000元而又未过期，则发出批准单和提货单。如果金额超过2000元，但已过期，则不发出批准单和提货单。如果金额低于2000元，则不论是否过期，都发出批准单和提货单，而且对低于2000元已过期的还需发出通知单。

（1）判定表 

![img](https://img-blog.csdnimg.cn/ac32b751b1f94c3ab1c4b7b38cbd9d13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_15,color_FFFFFF,t_70,g_se,x_16)

（2）判定树![img](https://img-blog.csdnimg.cn/99b625d64a574c92b37681543d806eb7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

5.某厂对部分职工重新分配工作的政策是：年龄在20岁以下者，初中文化程度脱产学习。高中文化程度当电工；年龄在2040岁之间者，中学文化程度男性当钳工，女性当车工，大学文化程度都当技术员。年龄在40岁以上者中学文化程度当材料员，大学文化程度当技术员。请用判定表与判定树描述上述问题的加工逻辑 。

判定条件取值

![img](https://img-blog.csdnimg.cn/16e206941e464b52ade7a41771680435.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 （1）判定表

![img](https://img-blog.csdnimg.cn/67dd1288e6574d10bc71baab9eae52ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树

![img](https://img-blog.csdnimg.cn/07466b2f33a54fcaa9f1e7530993c4a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16) 

# 实现

## 软件测试的步骤

测试过程按4个步骤进行，即单元测试（Unit Testing）、集成测试（Integrated Testing）、确认测试（Validation Testing）和系统测试（System Testing）及发版测试。

黑盒测试 (Black box testing) ── 不考虑内部设计和代码，根据需求和功能进行测试。

白盒测试 (White box testing) ── 根据应用软件的代码的内部逻辑，按照代码的语句、分支、路径和条件进行测试。

功能测试（functional testing）——对一个应用软件的功能模块进行黑盒测试。这种测试应当由测试人员进行。但这并不意味着程序员在推出软件之前不进行代码检查。（这一原则适用于所有的测试阶段。）

系统测试 ── 针对全部需求说明进行黑盒测试，包括系统中所有的部件。

回归测试 (regression testing) ── 每当软件经过了整理、修改、或者其环境发生变化，都重复进行测试。很难说需要进行多少次回归测试，特别是是到了开发周期的最后阶段。进行此种测试，特别适于使用自动测试工具。

负荷试验 (load testing) ── 在大负荷条件下对应用软件进行测试。例如测试一个网站在不同负荷情况下的状况，以确定在什么情况下系统响应速度下降或是出现故障。

压力测试 (stress testing) ── 经常可以与“负荷测试”或“性能测试”相互代替。这种测试是用来检查系统在下列条件下的情况：在非正常的巨大负荷下、某些动作和输入大量重复、输入大数、对数据库进行非常复杂的查询，等等。

性能测试 (performance testing) ── 经常可以与“压力测试”或“负荷测试”相互代替。理想的“性能测试”(也包括其他任何类型的测试) 都应在质量保障和测试计划的文档终予以规定。

## 软件测试的方法

### 白盒测试技术

#### 1、逻辑覆盖法

原则：以程序内部的逻辑结构为基础设计测试用例。

逻辑覆盖包括**语句覆盖**、**判定覆盖**、**条件覆**盖、**判定／条件覆盖**、**条件组合覆盖**和**路径覆盖。**

以上六种覆盖标准发现错误的能力呈**由弱到强**变化：

1. 语句覆盖每条语句至少执行一次。
2. 判定覆盖每个判定的每个分支至少执行一次。
3. 条件覆盖每个判定的每个条件应取到各种可能的值。
4. 判定条件覆盖同时满足判定覆盖条件覆盖。
5. 条件组合覆盖每个判定中各条件的每一种组合至少出现一次。
6. 路径覆盖使程序中每一条可能的路径至少执行一次。

之所以六种覆盖标准发现错误的能力有差异，是因为使用每种覆盖标准所设计的测试用例对程序内部逻辑的**覆盖率**不同。

覆盖率是什么？

覆盖率是用来**度量测试完整性**的一个指标。

![img](https://img-blog.csdnimg.cn/098aabb998314c2b8dc2d69a4e1170b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

以下图的示例代码为例，分别说明每种覆盖标准的测试覆盖率。

![img](https://img-blog.csdnimg.cn/fe5ad2aee35b4b82a7ccc20cbb2cd314.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.1、语句覆盖（SC）**

语句覆盖：设计足够多的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现**运算中的逻辑关系错误**。

![img](https://img-blog.csdnimg.cn/3c3e9236e1fc49f78a037ffb5d336c1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_16,color_FFFFFF,t_70,g_se,x_16)

示例代码中共有4条可执行语句

设计测试用例执行了3条，语句覆盖率为3/4=75%

![img](https://img-blog.csdnimg.cn/67041d9218324cadab9cec92ff956090.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/69adc24d64804e50b25f0e2b7e8c0133.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.2、判定覆盖（DC）**

判定覆盖：设计足够多的测试用例，使得程序中的**每一个判断**至少**获得一次“真”和一次“假”**，即使得程序流程图中的**每一个真假分支至少被执行一次**。

但若程序中的判定是有几个条件联合构成时，未必能发现每个条件的错误。

![img](https://img-blog.csdnimg.cn/3e655bcd8a3b4542845511bf25ef9abd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/4419a68fb5e84bbbbc1e402a855665ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.3、条件覆盖（CC）**

条件覆盖：设计足够多的测试用例，使得运行这些测试用例时，使得判定中的**每个条件至少有一次取真值，有一次取假值**。

但未必能覆盖全部分支。

![img](https://img-blog.csdnimg.cn/f7c1a7f7a2454f7b82aeb1a5a243123d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_15,color_FFFFFF,t_70,g_se,x_16)

案例代码中有判定2个，条件3个，条件结果6个

设计测试用例执行了5个条件结果，条件覆盖率为5/6=83%

![img](https://img-blog.csdnimg.cn/9a5d868d60eb4a2498487f6a1277500d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/a02e6c0d34dc45938bafbb14d65ff117.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.4、判定／条件覆盖（DCC）**

判定／条件覆盖：设计足够多的测试用例，使得被测试程序中的**每个判断本身的判定结果（真假）至少满足一次**，同时，**每个逻辑条件的可能值（真假）也至少被满足一次**。

即同时**满足100%判定覆盖**和**100%条件覆盖**的标准。

![img](https://img-blog.csdnimg.cn/3addf7cb28934943b936b5bb3fbc4904.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_16,color_FFFFFF,t_70,g_se,x_16)

示例代码中有判定2个，条件3个，判定结果4个，条件结果6个

设计测试用例执行了3个判定结果，5个条件结果，判定条件覆盖率为：（3+5）/（4+6）=80%

![img](https://img-blog.csdnimg.cn/9fa75f2ed80a4e24ba8468e8d84d9011.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/1f5797a00c5741f797af43a02c446007.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.5、条件组合覆盖（BCCC）**

条件组合覆盖：设计足够多的测试用例，使得被测试程序中的**每个判定中条件结果**的**所有可能组合至少执行一次**。

显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。

示例代码中有判定2个，条件3个（判定1有2个条件，判定2有1个条件），判定1的条件组合为4个，判定2的条件组合为2个

设计测试用例执行了5个条件组合，条件组合覆盖率为：5/（4+2）=83%

![img](https://img-blog.csdnimg.cn/6d324b47a40c4f328c6d5c54af108f8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)



 ![img](https://img-blog.csdnimg.cn/34a93284c3ea40d991b509d4b47b04ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.6、路径覆盖**

路径覆盖：设计足够多的测试用例，**覆盖被测试程序中的所有可能路径，**是最强的覆盖准则。

案例代码中共有4条路径

设计测试用例执行了3条路径，路径覆盖率为3/4=75%

![img](https://img-blog.csdnimg.cn/e5a2c500261947bc8e6a35253a0e855f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

#### **2、基本路径测试法**

理想情况下，**路径覆盖**需要覆盖程序中所有可能的路径。但在路径数目很大时，真正做到完全覆盖是很困难的，

必须把**覆盖路径数目压缩**到一定限度。例如**程序中的循环体只执行一次**。

所以，**基本路径测试法**可以理解为压缩后的路径覆盖。

基本路径测试法如何操作？

在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例。

**一条<font color='red'>独立路径</font>是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路**，通俗的来说就是该路径要比其他路径至少多一个新的路径，并且该路径应该是从头至尾的，不可间断。

![img](https://img-blog.csdnimg.cn/e00d9a81483d43e6918b09d72c5fdff2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

程序的控制流图：描述程序控制流的一种图示方法

程序环路复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数。

导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。

准备测试用例：确保基本路径集中的每一条路径的执行。

![img](https://img-blog.csdnimg.cn/6d7d08332f794ccca8f39b6489d5e54b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/639ba1e6dace4e6bb00c4243e80f79dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

### 黑盒测试技术

> 黑盒测试也称为功能测试和数据驱动测试。它将被测软件视为一个无法打开的黑盒，主要根据功能需求设计测试用例和测试。把产品软件想象成一个只有出口和入口的黑盒。在测试过程中，你只需要知道向黑盒输入什么，知道黑盒会产生什么结果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d6941dd7a5b34155b43436e3fcfbee73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_20,color_FFFFFF,t_70,g_se,x_16)

> 黑盒测试方法主要有**等价类划分**、**边界值分析**、**错误推测**等，主要用于软件验证测试。**“黑盒”法侧重于程序的外部结构，不考虑内部逻辑结构，针对测试软件界面和软件功能。**“黑盒”方法是详尽的输入测试，只有当所有可能的输入都用作测试条件时，才能以这种方式检测程序中的所有错误。事实上，有无数个测试用例。人们不仅要测试所有合法的输入，还要测试那些非法但可能的输入。

#### 1、等价类划分法

根据程序的I/O特性，将程序的定义域划分为有限个等价区段 —“**等价类**”，从等价类中选择出的用例，具有“代表性”。

等价类分为：

- 有效等价类

> 是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。《软件质量与测试》

即：符合程序要求，合理且有意义

- 无效等价类

> 是指对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合.利用无效等价类可检验程序是否实现了规格说明中所规定的功能和性能。《软件质量与测试》

即：不符合要求，不合理且有意义

***等价类划分法设计步骤***

- 确定等价类的原则在输入条件规定了取值范围或值的个数的情况下,可以确立一个有效等价类和两个无效等价类
- 在输入条件规定了输入值的集合或者规定了"必须如何"的条件的情况下,可以确立一个有效等价类和一个无效等价类
- 在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类在规定了输入数据的一组值(假定n个),并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类
- 在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类(符合规则和若干个无效等价类(从不同角度违度规则)
- 在确知己划分的等价类中,各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步地划分为更小的等价类

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea306df93fb54cea9931f8f02d3d287a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_16,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/e87634ccd18a47cdaa1d9b2040e8486c.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/cae15388743742e78f5327b705ae877f.png)

> 如果等价类中的一个测试数据不能捕获缺陷，那么选择该等价类中的其他测试数据也不会捕获缺陷；同样的，如果等价类中的一个测试数据能够捕获一个缺陷，那么选择该等价类中的其他数据测试也能捕获该缺陷。

> 注: 在寻找等价划分时，考虑吧软件的中具有的相似输入、相似输出、相似操作的分在一起，这写组就是等价划分。
> 如果为了减少测试用例的数量过度划分等价类，就有漏掉哪些可能暴露软件缺陷的测试风险。

#### 2、边界值分析法

> 边界值分析是通过选择等价类边界的测试用例。边界值分析法不仅重视输入条件边界，而且也必须考虑输出域边界。它是对等价类划分方法的补充。《软件质量与测试》

即：对软件的输入或输出边界进行测试 作为等价类划分法的一种补充测试

![在这里插入图片描述](https://img-blog.csdnimg.cn/9426218419f142658c19238895a84ce2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_20,color_FFFFFF,t_70,g_se,x_16)
边界值只是一个特定的数据。
例如,文本框需要输入6到18位字符。
边界值有:

1. 6字符
2. 18 字符
   次边界。边界附近的值,按照系统规定的单位或者计算方式,一个数据的差异。
   例如,字符就是个,一个字符,没有半个字符的说法;人民币金额,最小单位是0.01元(1分), ATM机取款和存款,最小单位就是100元,只能是100元的整数倍

##### 边界值的选择原则

- 如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据
- 如果输入条件规定了值的个数,则用最大个数、最小个数、比最小个数少1、比最大个数多1的数作为测试数据
- 根据规格说明的每个输出条件,使用前面的原则①
- 根据规格说明的每个输出条件,应用前面的原则②
- 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例
- 如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构边界上的值作为测试用例。

> 等价类划分方法和边界值分析方法着重考虑输入条件，而不考虑输入条件的各种组合，也不考虑输入条件之间的相互制约关系。

#### 3、错误推测法

错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。

错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。

> 例如，在单元测试时曾列出的许多在模块中常见的错误。以前产品测试中曾经发现的错误等，这些就是经验的总结。还有，输入数据和输出数据为0的情况。
> 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。

# 面向对象编程

## 1 面向对象方法学

### 1.1 面向对象方法学概述

**面向对象编程**（Object-Oriented Programming，简称OOP）是一种编程范式，尽可能使用人的思维方式，将数据和操作数据的方法打包在一起，形成一个对象。对象可以被看作是现实世界中的一个实体，具有属性和行为。

面对对象方法具有下面4个要点：

> 1、认为客观世界是由各种对象组成的，任何事物都是对象，复杂的对象可以由比较简单的对象由某种方式组合而成。
>
> 2、吧所有对象划分为各种对象类(class)，每个对象类定义了一组数据和操作数据的方法。
>
> 3、按照子类和父类的关系，把若干个对象类组成一个层次结构系统。
>
> 4、对象彼此之间仅能通过传递消息互相通讯。
>
> 综上所述，面向对象的方法可以用下列的方程来概述：
>
> ​			**OOP 	= 	 objects 	+ 	classes	+	inheritance	+	communication with messages**

### 1.2 面向对象方法学优点

> 面向对象方法学有以下几个优点：
>
> 1. 与人类习惯的思维方式一致
> 2. 稳定性较好
> 3. 可重用性好
> 4. 交易开发大型软件产品
> 5. 可维护性好

### 1.3 面向对象的三大特性

#### 继承（Extend）

> 继承是指从已有的类中派生出新的类，新类继承了原有类的所有数据和方法，并可以在此基础上进行扩展或重写。继承可以减少代码的重复，提高代码的复用性，同时也能够使代码更加清晰和易于维护。

> **继承的优点：**
>
> - 提高类代码的复用性
>
> - 提高了代码的维护性
>
> - 使得类和类产生了关系，是多态的前提(它也是继承的一个弊端，类的耦合性提高了)

#### 封装（Encapsulation)

> 封装是指将对象的数据和方法隐藏在类内部，只向外界提供接口（public方法）来访问。封装使得数据和方法的实现细节对外部隐藏，使得程序更加安全、稳定、易于维护和修改。

> **封装的优点：**
>
> - 通过封装，我们可以保护代码被破坏，提高数据安全性。
>
>   使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑限制对属性的不合理操作。
>
> - 通过封装，我们提高了代码的复用性（有些方法、类在很多地方都能多次反复使用）
>
> - 通过封装，带来的高内聚和低耦合，使用不同对象、不同模块之间能更好的协同，同时便于修改，增强代码的可维护性
>
>   - 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；
>   - 低耦合 ：仅对外暴露少量的方法用于使用

#### 多态（Polymorphism）

> 多态同一个行为具有多个不同表现形式或形态，从编程语言上讲就是同一个接口可以实现多种不同的行为。在OOP中，多态可以通过**C++虚函数、函数重载、Java接口**等方式实现。多态可以让程序更加灵活，提高程序的可扩展性和可维护性。
>
> Java中的多态性可以分为两种：
>
> 1. <font color='cornflowerblue'>**方法多态性**</font>：重载与覆写
>
>    重载：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能。
>    覆写：同一个方法，根据操作的子类不同，所完成的功能也不同。
>
> 2. <font color='cornflowerblue'>**对象多态性**</font>：父子类对象的转换。
>
>    向上转型：子类对象变为父类对象，格式：父类 父类对象 = 子类实例，自动；
>    向下转型：父类对象变为子类对象，格式：子类 子类对象 = (子类)父类实例，强制。

综上所述，OOP通过抽象、封装、继承和多态等特性，使得程序更加清晰、安全、稳定、易于维护和修改，同时也提高了代码的复用性和可扩展性。OOP已成为现代程序设计的主流范式之一，广泛应用于各个领域的程序设计和开发中。

#### 补充特征：抽象（Abstract)

> **抽象是从众多的事物中抽取出共同的、本质属性的特征，而舍弃其非本质的特征的过程。**具体地说，抽象就是人们在实践的基础上，对于丰富的[感性材料](https://baike.baidu.com/item/感性材料/5050824)通过去粗取精、去伪存真、由此及彼、由表及里的加工制作，形成[概念](https://baike.baidu.com/item/概念/829047)、[判断](https://baike.baidu.com/item/判断/33345)、[推理](https://baike.baidu.com/item/推理/1905524)等[思维形式](https://baike.baidu.com/item/思维形式/2302226)，以反映事物的本质和[规律](https://baike.baidu.com/item/规律/3311038)的方法。
>
> ​    其实说白了，抽象就是把事物的共同特征总结为一点。 他和具体又是相对的。就比如说“男人”对于“人类”是具体的，而“动物”对于“人类”又是抽象的。抽象---》抽出相同特征的对象，他也有个同义词叫归类。

## 2 面向对象的概念

### 2.1 对象

#### 2.1.1 对象的概念

> **对象（Object）**指的是对问题域中某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与他交互的能力，换句话来说，<font color='red'>对象就是属性值和操作的封装</font>。

#### 2.1.2 对象的特点

> 1. 以数据为中心
> 2. 对象是主动的
> 3. 实现了数据的封装
> 4. 本质上具有并行性
> 5. 模块独立性较好

#### 2.1.3 其他概念

##### 类

> 类（class）是对具有相同数据和相同操作的一组相似对象的集合。类的定义包括了在类中的一组数据和在类中的操作数据的方法。

## 3 面向对象建模

> tips：模型就是对事物做出的一组抽象，是对失误的一中无歧义的书面描述。

### 3.1 对象模型

#### 3.1.1 类图

##### 类图基本符号

> #### 类的定义
>
> UML中类的图形符号为**长方形**，用两条横线把长方形分**上、中、下**3个区域，3个区域分别放类**的名字、属性和服务**
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/289eee0464d14e3eae62fbbd8271d215.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_10,color_FFFFFF,t_70,g_se,x_16)

> ##### 属性具体格式为
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/1ee954bc72314eb39f8b5ad1b03428c1.png)
>
> - **可见性**：有公有的（+）、私有的（-）和保护的（#）
> - **类型名**：表示该属性的数据类型
> - **赋值**：在创建类的实例时应给其他属性赋值，如果给某个属性定义了初值，则该初值可作为创建实例时这个属性的默认值
> - **性质串**：明确地列出该属性所有可能取值，用逗号隔开
>
> **例如：- 货单数 : Integer = 0**

> ##### 服务具体格式为
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f12ee5b188ed400fa583855d6afbb949.png)
>
> - **可见性**：有公有的（+）、私有的（-）和保护的（#）
> - **参数表**：用逗号隔开不同参数，每个参数语法为 “`参数名:类型名=默认值`”

##### 表示关系的符号

###### （1）关联

> **定义**
>
> 关联表示两个类的对象之间存在某种**语义上的联系**
>
> 在任何关联中都会涉及**参与此关联的对象所扮演的角色**，在某些情况下显式标明角色名有助于别人理解类
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/7fe729dc68b146749fed5683020684e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> - 如果没有显式标出角色名，则意味着用类名作为角色名

> **普通关联**
>
> ①：定义
>
> 普通关联是最常见的关联关系，**只要在类与类之间存在连接关系就可以用普通关联表示**
>
> ②：表示
>
> - 第一，普通关联的图示符号是**连接两个类之间的直线**，如下图
> - 第二，关联是**双向**的，可为关联起一个名字。在名字前面(或后面)加一个**表示关联方向的黑三角**
> - 第三，在表示关联的直线两端可以写上**重数**，它表示该类有多少个对象与对方的一个对象连接。**未明确标出关联的重数，则默认重数是1**
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/0884f8bd8ba94f93be1ab862485f742c.png)

>  **限定关联**
>
> ①：定义
>
> 限定关联通常用在**一对多或多对多**的关联关系中，可以把模型中的重数从[一对多](https://so.csdn.net/so/search?q=一对多&spm=1001.2101.3001.7020)变成一对一， 或从多对多简化成多对一
>
> ②：表示
>
> 在类图中把**限定词**放在关联关系**末端的一个小方框内**。![在这里插入图片描述](https://img-blog.csdnimg.cn/e84060716e6d4a8f9bb46bad60a3b7e5.png)
>
> - 利用限定词“文件名”表示了目录与文件之间的关系，利用限定词把**一对多关系简化成了一对一关系**
>
> ③：意义
>
> 限定提高了语义精确性，增强了查询能力

> **关联类**
>
> ①：定义
>
> 为了说明关联的性质，可能需要一些**附加信息**。关联类可以用来**记录相关信息**
>
> ②：表示
>
> 关联类通过一条**虚线**与关联连接
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/23d3625cdc294078b93ed7a2f1ce1ce2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> - 关联中的每个连接与关联类的一个对象相联系

###### （2）聚集（它是关联的特例）

###### （3）泛化（本质就是继承）

###### （4）依赖和细化

### 3.2 动态模型

### 3.3 功能模型

