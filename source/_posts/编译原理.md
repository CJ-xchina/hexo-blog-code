---
title: 编译原理(复试版1)
date: 2023-3-18 19:49:14
tags: 
categories: 编译原理
keywords: 
description: 准备复试时出现的一些题目
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---
<meta name="referrer" content="no-referrer"/>
# 编译原理概述

## 编译程序工作过程

> （1） 词法分析
>
> 词法分析的任务是对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。执行词法分析的程序称为词法分析程序或扫描器。
>
> 源程序中的单词符号经扫描器分析，一般产生二元式：单词种别；单词自身的值。单词种别通常用整数编码，如果一个种别只含一个单词符号，那么对这个单词符号，种别编码就完全代表它自身的值了。若一个种别含有许多个单词符号，那么，对于它的每个单词符号，除了给出种别编码以外，还应给出自身的值。
>
> （2） 语法分析
>
> 编译程序的[语法分析器](https://baike.baidu.com/item/语法分析器/10598664?fromModule=lemma_inlink)以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。编译程序的语法规则可用上下文无关文法来刻画。
>
> 语法分析的方法分为两种：自上而下分析法和自下而上分析法。自上而下就是从文法的开始符号出发，向下推导，推出句子。而自下而上分析法采用的是移进归约法，基本思想是：用一个寄存符号的先进后出栈，把输入符号一个一个地移进栈里，当栈顶形成某个产生式的一个候选式时，即把栈顶的这一部分归约成该产生式的左邻符号。
>
> （3） 语义分析与中间代码生成
>
> 中间代码是源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现。中间代码即为中间语言程序，中间语言的复杂性介于源程序语言和机器语言之间。中间语言有多种形式，常见的有逆波兰记号、四元式、三元式和树。
>
> （4） 代码优化
>
> 代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。
>
> 有两类优化：一类是对语法分析后的中间代码进行优化，它不依赖于具体的计算机；另一类是在生成目标代码时进行的，它在很大程度上依赖于具体的计算机。对于前一类优化，根据它所涉及的程序范围可分为局部优化、循环优化和全局优化三个不同的级别。
>
> （5） 目标代码生成
>
> 目标代码生成是编译的最后一个阶段。目标[代码生成器](https://baike.baidu.com/item/代码生成器/733038?fromModule=lemma_inlink)把语法分析后或优化后的中间代码变换成目标代码。目标代码有三种形式：
>
> ① 可以立即执行的机器语言代码，所有地址都重定位；
>
> ② 待装配的机器语言模块，当需要执行时，由连接装入程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码；
>
> ③ 汇编语言代码，须经过汇编程序汇编后，成为可执行的机器语言代码。
>
> 目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：一是如何生成较短的目标代码；二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。 [3] 



## 除了上述五个过程，每个阶段还涉及到什么

> 涉及到**表格管理**和**错误处理**两个重要内容



# 四型文法

​    Chomsky根据对产生式要求的不同，将文法分为4类，通常称为**Chomsky体系。**

​    设文法G=（V，T，P，S），还有一种表示方法为：G=（![V_{N}](https://private.codecogs.com/gif.latex?V_%7BN%7D)，![V_{T}](https://private.codecogs.com/gif.latex?V_%7BT%7D)，P，S)，两者是相同的，本文采用前者。

​    快速查阅：0型文法也叫短语结构文法，PSG。0型语言PSL也叫短语结构语言或递归可枚举集。

​             1型文法也叫上下文有关文法，CSG。1型语言CSL也叫上下文有关语言。

​             2型文法也叫上下文无关文法，CFG。2型语言CFL也叫上下文无关语言。

​             3型文法也叫正则文法或正规文法，RG。3型语言RL也叫正则语言或正规语言。分左[线性](https://so.csdn.net/so/search?q=线性&spm=1001.2101.3001.7020)文法和右线性文法。

## 一、0型文法：短语结构文法

​    若P中任一产生式都有一般形式![\alpha \rightarrow \beta ,\alpha \in V^{+},\beta \in V^{*}](https://private.codecogs.com/gif.latex?%5Calpha%20%5Crightarrow%20%5Cbeta%20%2C%5Calpha%20%5Cin%20V%5E%7B&plus;%7D%2C%5Cbeta%20%5Cin%20V%5E%7B*%7D)，且对![\alpha \beta](https://private.codecogs.com/gif.latex?%5Calpha%20%5Cbeta)不加任何限制，则称G为**0型文法**，也叫**短语结构文法**，记为**PSG**(Phrase Structure Grammar)。0型文法没有任何限制，可以描述任何语言，但是很难用计算机处理。无限制文法的产生式规则左右可以是任意符号串。

​     由0型文法生成的语言L(G)称为**0型语言**，也叫**短语结构语言(PSL** Phrase Structure Language**)**或**递归可枚举集**(recursively enumerable set)。它可由**图灵机**识别。

​    示例：

![img](https://img-blog.csdnimg.cn/2020041310093096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Q1MjM3MA==,size_16,color_FFFFFF,t_70)

## 二、1型文法：上下文相关文法

产生式规则左边有一个非终结符号和一些终结符号，右边可以是任意符号串。上下文相关文法描述的语言比上下文无关文法更复杂，包括自然语言的一部分，例如汉语的语法。

## 三、2型文法：上下文无关文法

上下文无关文法就是说这个文法中**所有的产生式左边只有一个非终结符**，比如：

> S -> aSb
>
> S -> ab

这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是**上下文无关文法**，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符，比如：

> aSb -> aaSbb
>
> S -> ab

这就是**上下文相关文法**，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。

## 四、3型文法：正则文法

产生式规则左边只有一个非终结符号，右边只能是终结符号和一个非终结符号的拼接。正则文法描述的语言具有很强的结构化特征，例如，它们可以描述具有重复、交替和嵌套结构的字符串。
$$
A\longrightarrow aB,A\longrightarrow a
$$


当你需要匹配或搜索一个字符串时，正则表达式是一种非常强大的工具。正则表达式（也称为正则表达式模式）是一种用于描述字符串模式的形式语言。正则表达式由一系列字符和特殊字符组成，这些字符和特殊字符定义了一个模式，用于匹配和搜索字符串。

正则表达式的基本元素包括：

> 1. 字符 - 用于匹配自身。例如，字符 "a" 匹配字符串中的 "a"。
> 2. 字符集 - 用于匹配一组字符中的任何一个字符。例如，字符集 "[abc]" 匹配字符串中的 "a"、"b" 或 "c"。
> 3. 范围 - 用于匹配一定范围内的字符。例如，"[a-z]" 匹配任何小写字母。
> 4. 量词 - 用于指定字符、字符集或子表达式的出现次数。例如，字符 "a" 后面跟着量词 "+" 表示字符 "a" 可以出现一次或多次。“a*”代表着‘a’可以出现任意次。
> 5. 捕获组 - 用于分组并捕获匹配的字符。捕获组可以用于替换、后向引用和分组捕获等操作。

















