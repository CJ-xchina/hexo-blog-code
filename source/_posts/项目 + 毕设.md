---
title: 项目 + 毕业设计
date: 2023-03-18 00:00:00
tags: 
categories: 考研复试
keywords:
description:
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
---
<meta name="referrer" content="no-referrer"/>
# 毕业设计

## 1 区块链基础

### 1.1 什么是区块链

**区块链（Blockchain）**是一种去中心化的分布式账本技术，它通过密码学和共识算法等技术手段，保证了数据在网络中的不可篡改性和安全性，使得区块链数据可以公开透明地被多个参与者共享、存储和验证，从而实现了一种去信任化的分布式数据管理方式。

### 1.2 区块链的特点

区块链的主要特点包括：

1. **去中心化**：区块链的数据存储在网络中的多个节点上，没有中心化的管理机构，所有参与者都有权利共同维护和管理网络。
2. **不可篡改**：区块链使用密码学技术和共识算法等手段，确保数据的不可篡改性和安全性。
3. **共识机制**：区块链采用共识机制来解决数据一致性问题，确保所有参与者都能够达成共识，保证数据的真实性和可靠性。
4. **匿名性**：区块链上的交易和数据记录是匿名的，保护了用户的隐私和安全。
5. **开放性**：区块链是一种开放的技术，任何人都可以参与其中，共同维护和管理网络。

### 1.3 区块的数据结构

![image-20230306190805778](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230306190805778.png)

- **版本号（Version Number）**：指定了当前区块链协议的版本号，每个区块链协议的版本都有相应的规范和文档说明，版本号用于指定使用哪个版本的规范。
- **前一区块哈希值（Previous Block Hash）**：指向前一个区块的哈希值，通过这个参数，区块链头将多个区块链接在一起形成链式结构，从而确保了区块链的不可篡改性和完整性。
- **Merkle 根哈希值（Merkle Root Hash）**：Merkle 根是由区块中所有交易的哈希值构成的二叉树根节点的哈希值，它可以确保区块中所有交易的完整性。
- **时间戳（Timestamp）**：指定了当前区块被创建的时间，一般使用UTC时间。
- **难度目标（Difficulty Target）**：用于控制区块链中的挖矿难度，难度目标的设置可以影响到区块链的安全性和运行效率。
- **随机数（Nonce）**：通过不断地改变随机数的值，矿工可以尝试不断地寻找符合当前难度目标的哈希值，以获得新的区块奖励。
- **交易信息（Transaction）**：每一条交易信息对应一笔用户交易

通过一块又一块的区块通过 Previous Block Hash 相链接，最终组成了一条区块链：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200710212957480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xhb1l1YW5QeXRob24=,size_16,color_FFFFFF,t_70)



### 1.4 Merkle 树

刚刚我们在区块头中提到了（Merkle Tree），在区块链的构建中，。

#### 1.4.1 Merkle 树的概念

默克尔树（Merkle Tree）其实并不是一个真实存放在区块链头部的数据结构，Merkle树以树根的形式保存在区块头中，那么为什么要这么设计呢？

假想一个区块中共保留了 1000 条交易记录，对于这些交易记录，每一条都有可能被篡改的风险，为了防止篡改的出现，我们可以通过哈希算法将交易记录的数据映射为哈希值，这样就算是交易记录被篡改，收到该笔交易信息并核查交易的用户同样可以通过哈希算法算出一个新的哈希值与旧的哈希值进行比对，从而判断交易是否被修改。

但是这样做需要每一笔交易都将旧的哈希值存放在交易体中以便比对，这样不仅占用了更多的空间同时也不易于比对，这时 Merkle 树的作用就体现出来了。

如果将每条交易的哈希值看做一个叶子节点，从下往上将两个相邻叶子节点的组合再次进行哈希运算得到新的哈希值，新的哈希值成为树节点继续与相邻的树节点组合成新的哈希值。

![img](https://img-blog.csdnimg.cn/img_convert/8a24ff5df6fa631083f2e05d734a1827.png)

在重复一定次数后直到形成唯一的根节点。这个唯一的根节点也就是保存在区块头部的 Merkle 根。

#### 1.4.2 Merkle 树完整性的验证

验证 Merkle 树的完整性通常需要使用 Merkle 根（Merkle Root）来进行比对。在区块链中，每个区块的交易数据都被组织成 Merkle 树，并且每个区块头都包含了一个 Merkle 根的哈希值。通过比对这个哈希值，可以验证 Merkle 树的完整性。

具体的验证过程可以如下：

1. 从区块头中获取 Merkle 根的哈希值。
2. 计算当前区块中所有交易数据的哈希值，并将这些哈希值按照事先规定的顺序组成一个 Merkle 树。
3. 最终的 Merkle 根节点的哈希值就是当前区块头中的 Merkle 根哈希值，如果这两个哈希值不相同，说明 Merkle 树已经被修改过，当前区块数据可能已经被篡改。

这样一来通过交易记录生成的新 Merkle根与旧 Merkle根的比对，就可以判断交易记录是否被更改。

#### 1.4.3 Merkle 树的Java实现

```java
package com.dce.blockchain.web.util;

import com.dce.blockchain.web.entity.Transaction;

import java.util.ArrayList;
import java.util.List;

/**
 * @program: blockChain-java
 * @description: 默克尔树的实现
 * @author: CuiJieXiang_1023
 * @create: 2023-03-04 13:34
 **/
public class MerkleTree {
    private List<String> txs;
    private String root;

    /**
     *
     * @param transactions 放入该区块的交易记录
     */
    public MerkleTree(List<Transaction> transactions) {
        txs = new ArrayList<>();
        for (int i = 0; i < transactions.size(); i++) {
            txs.add(transactions.get(i).transactionId);
        }
        root = "";
    }

    /**
     * 构造Merkle Tree，返回根节点
     * @return
     */
    private String buildTree() {
        if (txs.isEmpty()) {
            return null;
        }
        if (txs.size() == 1) {
            return txs.get(0);
        }
        List<String> tempTxs = new ArrayList<>(txs);

        List<String> newTxs = getNewTxList(tempTxs);
        while (newTxs.size() > 1) {
            newTxs = getNewTxList(newTxs);
        }

        root = newTxs.get(0);
        return root;
    }

    /**
     * 构造 Merkle Tree
     * @param txs
     * @return
     */
    private List<String> getNewTxList(List<String> txs) {
        List<String> newTxs = new ArrayList<>();
        int index = 0;
        while (index < txs.size()) {
            String left = txs.get(index);
            index++;

            String right = "";
            if (index != txs.size()) {
                right = txs.get(index);
            }
            // 新的Merkle树节点
            newTxs.add(CryptoUtil.applySha256(left + right));
            index++;
        }
        return newTxs;
    }

    /**
     * 获取交易的merkle树的根节点，当一个区块中包含大量的transaction时，计算所有的hash值是不可取的
     * 所以使用merkel tree对全部hash值进行一个计算。
     *
     * @param transactions
     * @return
     */
    public static String getMerkleRoot(List<Transaction> transactions) {
        MerkleTree merkleTree = new MerkleTree(transactions);
        return merkleTree.buildTree();
    }
}
```

## 2 区块链的实现

### 2.1 区块链加密算法

#### 2.1.1 非对称加密算法 — ECC

**椭圆加密算法（ECC）**是一种公钥加密体制，最初由 Koblitz 和 Miller 两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。

简单来说，它就是通过在一个特定的椭圆曲线上选取点，利用这些点的数学特性来实现加密和解密的过程。与传统的加密算法相比，ECC 具有更高的安全性和更短的密钥长度，能够更好地保护数据的安全性。

#### 2.1.2 散列算法 — SHA-256

散列函数，又称哈希算法，把任意长的输入字符串变化成固定长的输出字符串的一种函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数散把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（或哈希值）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。

SHA - 256 算法可以将任意长度的数据映射为256 bit长的哈希值。

[SHA256算法原理详解](https://blog.csdn.net/u011583927/article/details/80905740?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167810398416800222843353%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167810398416800222843353&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-80905740-null-null.142^v73^insert_down3,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=sha256&spm=1018.2226.3001.4187)

### 2.2 公钥与私钥

在区块链技术中经常听说公钥与私钥，其实他们都是非对称加密算法的产物。私钥不能被他人知晓，公钥可以公开。

#### 2.2.1 私钥

私钥就是一个随机选出来的数字，可通过**伪随机数生成器（Pseudo-random Number Generator）生成**。比特币地址中的资金取决于对私钥的控制，你拥有私钥就相当于你用这个私钥下的地址的所有的比特币。所以必须对私钥保密以及防止丢失（难以复原），一旦丢失，其地址下的比特币也相当于没了。

一个随机数生成一个私钥是最重要的一步，需要找到足够的熵源，即随机性来源。比特币私钥本质上是与从1到2^256之间选一个数字无异，只要选取的结果是不可预测或者不可重复即可。**比特币是通过操作系统底层产生256位随机数**。

私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 *10^77，略小于 2^256）。要生成这样的一个私钥，要随机选择一个256位的数字， 并检查它是否小于n-1。从编程的角度来看，**一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算**，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，就用另一个随机数再重复一次。

> 警告：不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数。使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。使用随机数发生器的程序库时，需仔细研读其文档，以 确保它是加密安全的。正确实施CSPRNG是密钥安全性的关键所在。

以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占 4 位）：

```java
 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
```

> 提示比特币私钥空间的大小是 2^256，这是一个非常大的数字。用十进制表示的 话，大约是 10^77，而可见宇宙被估计只含有 10^80 个原子。

#### 2.2.2 公钥

**通过椭圆曲线乘法(ECC)**可以从私钥计算得到公钥，这是不可逆转的过程：K=k*G 。 其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。

> 提示：椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘 法）很容易做，而不可能在相反的方向（除法）做。 私钥的所有者可以容易地创建公钥，然后与世界共享，知道没有人可以从公钥中反转函数并计算出私钥。 这 个数学技巧成为证明比特币资金所有权的不可伪造和安全的数字签名的基础。

> <font color='red'>总结来说</font>：   公钥和私钥的作用主要就是用来加解密和加验签：
>
> - **公钥加密、私钥解密（传输加密数据）**
> - **私钥加签、公钥验签（验证信息来源）**

#### 2.2.3 公私钥与加密

公钥与私钥的出现，使去中心化数字加密信息传输成为了可能，下面举一个例子：

假如 A 与 B 进行通信，A在发送消息时：A使用B的公钥进行加密，B在接收信息时：使用自己的私钥进行解密，这样谁都无法截取到 A 对 B 的通信具体内容，只有拥有 B 秘钥的人才能将加密的信息解密。

为什么不使用私钥加密？

因为使用私钥加密之后，拥有公钥的人都可以进行解密，那岂不是泄露了 A 和 B 之间的消息了。而使用对方的公钥加密，那么就只有对方的私钥可以解密，也就是说不会有第三方可以解密内容
#### 2.2.4 公私钥与数字签名

在区块链中，公钥和私钥被广泛应用于身份认证和交易验证。例如，在比特币中，当用户要花费自己的比特币时，需要用私钥对交易进行签名，以证明自己是交易的合法拥有者。加签名的目的是为了防止他人随意使用他人数字货币，同时能够让接收到消息的一方确认该交易确实是由私钥的拥有者发起。

假设 A 向 B 转账，因为私钥只存在于A，也只有A才能对消息进行加签，这个过程就叫签名。公钥的作用就是验签，验证了就能知道消息的真伪，任何收到该转账信息的一方，都可以通过 A 的公钥来验证签名的真伪。

---

###   2.3 区块链共识机制

共识机制是区块链一大知识领域，<font color='red'> 通过算法和协议来保证各个节点对数据的一致性，确保所有节点都同意哪些数据可以被添加到区块链中</font>。早在区块链之前，就存在各种分布式的共识机制，共识机制不是因区块链所发明，但区块链却对共识机制推广和进步有着重要影响。

#### 工作量证明机制（PoW）

**PoW(Proof of Work)**，即工作量证明，闻名于比特币，俗称"挖矿”。PoW是指系统为达到某一目标而设置的度量方法。简单理解就是一份证明，用来确认你做过一定量的工作。监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。PoW是按劳分配，算力决定一起，谁的算力多谁记账的概率就越大，可理解为力量型比较。

**工作量证明（PoW）**通过计算一个数值( `nonce `)，挖矿节点需要找到一个符合特定条件的哈希值。这个条件是，计算出来的哈希值必须小于一个固定的值（中本聪的论文中说是要有一定数量的前置‘0’)，这个值称为**难度目标(difficulty)**。为了找到这个哈希值，挖矿节点需要反复尝试不同的哈希值，这就是所谓的计算工作量证明。这个过程需要耗费大量的计算资源和时间。

如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。

假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。

> 需要注意的是，难度目标是动态调整的，目的是保持比特币的产生速度稳定（大约10分钟产出新区块）。如果比特币网络中的挖矿节点数量增加，难度目标也会随之提高，反之亦然。这个机制保证了比特币的总产量不会超过2100万个，同时也保证了比特币的产生速度是可控的。

##### PoW 工作流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012215630944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkxODc1,size_16,color_FFFFFF,t_70#pic_center)
从流程图中看出，pow工作量证明的流程主要经历三步：

1.生成Merkle根哈希
	即节点自己生成一笔筹币交易，并且与其他所有即将打包的交易通过Merkle树算法生成Merkle根哈希，所以为什么说区块是工作量证明的三要素之一。

2.组装区块头
  区块头将被作为计算出工作量证明输出的一个输入参数，因此第一步计算出来的Merkle根哈希和区块头的其他组成部分组装成区块头。

3.计算出工作量证明的输出
  下面我们直接通过公式和一些伪代码去理解工作量证明的输出：

   i. 工作量证明的输出=SHA256(SHA256(区块头))

   ii. if（工作量证明的输出<目标值），证明工作量完成

   iii.if（工作量证明的输出>=目标值）,变更随机数，递归i的逻辑，继续与目标值比对。

上面的流程图及解析即pow工作量证明的整个过程。

##### PoW记账共识

前面三部分中讲解的是单节点工作量证明流程，有了这个计算流程，我们就得将其使用起来，在比特币平台中，中本聪就是运用的pow工作量证明来使全网节点达到51%及以上的共识记账，以下将介绍pow工作量证明共识是如何记账的？

交易产生到被加入区块的流程：

首先，客户端产生新的交易，向全网广播

第二，每个节点收到请求，将交易纳入区块中

第三，每个节点通过第三章中描述的pow工作量证明

第四，当某个节点找到了证明，向全网广播

第五，当且仅当该区块的交易是有效的且在之前中未存在的，其他节点才认同该区块的有效性

第六，接受该区块且在该区块的末尾制造新的区块

大概时序图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012220405959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkxODc1,size_16,color_FFFFFF,t_70#pic_center)

##### Pow优缺点

> 通过上面的描述，PoW优点很明显：
>
> 1. 完全去中心化（任何人都可以加入）；
> 2. 节点自由进出，容易实现；
> 3. 破坏系统花费的成本巨大；
>
> 关于破坏系统成本巨大可以分两层意思理解：
>
> 1. 在指定时间内，给定一个难度，找到答案的概率唯一地由所有参与者能够迭代哈希的速度决定。与之前的历史无关，与数据无关，只跟算力有关。
> 2. 掌握51%的算力对系统进行攻击所付出的代价远远大于作为一个系统的维护者和诚实参与者所得到的。
>
> 缺点也相当明显：
>
> 1. 对节点的性能网络环境要求高；
> 2. 浪费资源；
> 3. 每秒钟最多只能做七笔交易，效率低下；
> 4. 矿场的出现违背了去中心的初衷；
> 5. 不能确保最终一致性；
> 6. 比特币产量每4年减半，利益驱动性降低导致旷工数量减少从而导致比特币网络瘫痪。
>

#### 股权证明机制（PoS）

##### PoS共识机制工作原理

> **PoS（Proof of Stake）**：股权证明，与PoW相比，不需要证明你在记账前做了某项工作，而是证明你拥有某些财产。股权决定一起，谁的股权大，谁记账的概率就越大。相较于消耗大量算力的 PoW 共识机制，PoS 共识机制筛选旷工的方式更为简单。
>
> 首先 PoW 提出币龄这个概念，`币龄 = 持有的货币数 * 持有时间`，比如说我有100币，持有了30天，那么我的币龄就是3000。币龄越大的节点呢获取记账权（也就是生成区块）的概率越大，获取记账权力的节点需要将其所有币龄作为抵押保证生成区块不会出错。每次记完账之后，该节点的币龄就清空，每清空 365 个币龄，你将会从区块中获取到清空币龄 5% 的货币奖励，下面简述一下工作流程：
>
> 1. 加入PoS的都是持币人并称为验证者。
> 2. 在验证者中挑一个持币人给予权利生成新的区块，挑选顺序依据持币的多少。
> 3. 其余的持币人，也就是验证者进行对区块进行验证。验证通过生成新的区块。
> 4. 如果在一定时间内没有生成新区块，PoS会挑选下一个验证者，给予生成新区块的权利。
> 5. 以此类推，以区块链中最长的链为准。

##### PoS共识机制的优点

> **优点**
>
> 1. 节省能耗，相比于PoW的能源消耗，PoS大大缩减了能源消耗，简单来说就是省电。
> 2. 入门门槛低，用户参与度更高，只需要一台电脑，就可以称为验证者。
> 3. 在一定程度上缩短了共识达成时间。
>
> 在PoS中，节点拥有的币越多，设计利益越多，节点反而会愿意去维护这个系统的稳定。他们不会进行恶意攻击损害自己的利益。PoS可以更有效地防御51%算力攻击。

##### PoS共识机制的缺点

> - 我们再从pos的实现算法公式去看，币龄的计算公式中，假如一开始挖矿，只有创始区块中有币，也就是说其他矿机是没法参与挖矿的，因为币的个数这个值对他们来说永远是零，这也就是pos机制的缺陷之一币无法发行的问题。
>
> - 同样是从pos的实现算法公式可以分析到，币龄其实就是时间，一旦挖矿者囤积一定的币，很久很久之后发起攻击，这样他也将很容易拿到记账权，所以我们得给每个币设计一个时间上限（通常是90天）。
> - 设计时间上限后，虽然解决掉了部分挖矿者囤积币的缺陷，从公式中仍然看到还会面临一个问题，也就是币的数量这个因素还是会影响我们拿到记账权，很多挖矿者还会囤积代币，给代币造成流通上的缺陷。目前有些平台引入币龄按时间衰弱的方案来解决这一缺陷（例如：瑞迪币）。

### 2.4 交易与广播



#### 2 UTXO机制

##### 2.1 UTXO 概述

> **UTXO（Unspent Transaction Output，未花费交易输出）**是比特币和其他基于比特币协议的加密货币所使用的一种账户模型。
>
> 在UTXO机制中，<font color='red'>每一笔交易输出都是一个未花费交易输出（UTXO），每一个未花费的输出都可以被用于下一笔交易的输入，而每一笔交易的输入都会指向之前某个交易的UTXO</font>。因此，UTXO可以被看作是一个被锁定的“金库”，只有拥有相应私钥的人才能解锁并使用其中的数字货币。
>
> 举个例子，假设Alice要向Bob转账1个比特币。在这个过程中，Alice需要从之前的某笔交易中获取一个或多个UTXO，然后将其作为输入添加到新的交易中。Bob会在新的交易中得到一笔未花费的输出，也就是一个新的UTXO，他可以在之后的交易中使用这个UTXO。
>

##### 2.2 UTXO 机制的优点

> - **UTXO机制的优点之一是它可以有效地避免双重支付问题，因为每个UTXO只能被使用一次。**
> - **UTXO机制可以让比特币协议更加轻量级，因为它只需要跟踪未花费的交易输出而不需要维护每个账户的余额信息。**
>
> 需要注意的是，由于UTXO是一种基于交易的账户模型，因此它与传统的基于账户的账户模型有所不同。在UTXO机制中，一个人的余额并不是存储在一个单独的账户中，而是由该人拥有的UTXO的总和决定。因此，要计算某个人的余额，需要遍历整个交易历史并计算其拥有的所有UTXO的价值总和。
>

##### 2.3 UTXO交易细节

> 在UTXO（Unspent Transaction Output，未花费交易输出）机制中，每个UTXO都代表了一笔未花费的交易输出，用于记录某个地址的余额。因此，当你需要支付2元的时候，你需要找到一些UTXO，它们的总金额大于或等于2元，然后构造一个交易，将这些UTXO作为输入，输出2元给对方地址，以及剩余的UTXO找零给自己地址。
>
> 如果你只有5元的UTXO，而需要支付2元，则需要找到一笔金额大于等于2元的UTXO，例如3元的UTXO。这时，你可以构造一个交易，将这笔3元的UTXO作为输入，输出2元给对方地址，以及1元的UTXO找零给自己地址。这个过程通常由钱包程序自动完成。
>
> 如果你没有一笔金额大于等于2元的UTXO，但是有多笔小额UTXO，可以将它们合并成一笔大额UTXO，然后再进行支付。合并UTXO需要构造一笔新的交易，将多笔小额UTXO作为输入，将它们的总金额输出给一个新的地址，然后将这个新地址的UTXO作为找零输出给自己地址。注意，合并UTXO会增加交易大小和手续费，因此应该尽量避免。
>
> 在比特币交易中，"找零" 是指当你用一笔交易支付一定金额时，实际支付的金额比交易输入的总金额要少，因为一部分金额被作为交易费用而支付给矿工。在这种情况下，找零就是将未花费的交易输出返回给你自己，以便你可以在将来的交易中使用它们。
>
> 在实现交易时，你需要注意以下几点来实现"找零"：
>
> 1. 确定需要支付的金额，包括交易金额和矿工费用。
> 2. 找到足够的未花费的交易输出来支付这个金额。
> 3. 将这些交易输出作为交易的输入，并且将它们对应的公钥哈希和签名添加到输入中。
> 4. 如果你支付的金额少于交易输入的总金额，那么你需要创建一个新的交易输出来表示"找零"。
>
> 以下是一个简单的示例，演示如何实现"找零"。在这个示例中，我们假设有一个输入交易输出了 10 个比特币，我们需要支付 5 个比特币给收件人，并且支付 1 个比特币作为矿工费用。
>
> ```java
> scssCopy code// 构建交易输入
> TransactionInput input = new TransactionInput(txHash, outputIndex);
> input.setSignature(signature);
> input.setPublicKey(publicKey);
> 
> // 构建交易输出
> TransactionOutput output1 = new TransactionOutput(5.0, receiverAddress);
> TransactionOutput output2 = new TransactionOutput(4.0, changeAddress);
> 
> // 构建交易
> Transaction transaction = new Transaction();
> transaction.addInput(input);
> transaction.addOutput(output1);
> transaction.addOutput(output2);
> ```
>
> 在这个示例中，我们创建了一个输入，表示我们要花费一笔交易中的一个未花费的输出。我们还创建了两个输出，一个用于支付收件人，另一个用于"找零"。在这个示例中，我们假设支付的金额为 5 个比特币，因此我们需要创建一个值为 4 个比特币的交易输出来表示"找零"。
>

##### 2.4 UTXO 处理时注意事项

> 除了示例中提到的 UTXO 实现中需要考虑的细节和安全性问题外，以下是一些其他可能需要考虑的方面：
>
> 1. 双重支付攻击（Double-spending attack）：在 UTXO 实现中，需要确保同一笔 UTXO 只能被花费一次。否则，攻击者可能会花费同一笔 UTXO 两次，以欺诈商家或其他用户。为了避免这种攻击，可以使用一些技术，如 UTXO 索引和 UTXO 池等。
> 2. 确认时间（Confirmation time）：在 UTXO 实现中，需要考虑确认时间的问题。确认时间是指交易被其他节点接受和验证的时间。在 Bitcoin 网络中，通常需要等待 6 个区块（约 1 小时）才能确认一个交易。这是为了确保交易不会被双重支付攻击或其他欺诈行为所影响。
> 3. 交易费用（Transaction fee）：在 UTXO 实现中，需要考虑交易费用的问题。交易费用是指矿工从交易中获得的报酬。矿工通常会优先处理交易费用较高的交易，因此，如果交易费用较低，则可能需要等待更长的时间才能被处理。
> 4. 智能合约（Smart contract）：在一些 UTXO 实现中，还可能会包含智能合约的功能。智能合约是一种自动执行代码的程序，它可以用来实现复杂的交易逻辑和业务流程。
>

#### Wallet钱包

##### 钱包地址

钱包地址在区块链系统中具有接收和发送加密货币的作用，类似于传统银行账号。

例如，如果您想要接收某种加密货币（比如比特币），您需要告诉别人您的钱包地址，其他人可以将比特币发送到您的地址，这个过程是完全公开和透明的。发送方需要知道您的地址才能向您发送比特币，但他们不需要知道您的私钥。

另外，当您想要将比特币发送给其他人时，您需要使用您的私钥对交易进行签名，并将签名的结果一起广播到整个区块链网络中。这样其他人就可以验证这个交易是否合法，并更新区块链的状态。

因此，钱包地址在区块链系统中扮演着接收和发送加密货币的角色，并且与您的私钥相对应。

在区块链系统中，您需要得到接收者的钱包地址才能向其发送数字货币。发送方并不能直接使用接收方的公钥来发送数字货币。

在区块链中，数字货币的转移是通过交易来实现的。当您要向某个接收者发送数字货币时，您需要构建一笔交易，其中包括发送者的钱包地址、接收者的钱包地址、发送的数字货币数量等信息。接着，您需要使用您的私钥对这笔交易进行签名，证明这笔交易确实是由您发送的，并广播这个交易到整个区块链网络中。

接收者在接收到这笔交易后，会使用区块链的验证规则来验证这笔交易的有效性，并确认自己已经收到了相应数量的数字货币。在这个过程中，接收者并不需要向发送者提供任何信息，包括自己的公钥。

因此，虽然在区块链系统中，公钥可以用于验证数字签名的有效性，但在发送数字货币时，您需要使用接收者的钱包地址，而不是接收者的公钥。



##### 那我需要挖矿，是要处理哪些数据呢

如果您需要进行挖矿，您需要处理的数据通常包括：

1. 交易数据：您需要验证并处理交易数据。比如，在比特币中，您需要验证交易是否符合协议规则，包括交易输入是否来自有效的地址、交易输出是否符合规则等等。
2. 区块头数据：在比特币中，您需要对区块头数据进行 SHA-256 哈希计算，并寻找符合工作量证明算法规则的哈希值，也就是需要寻找符合协议要求的“难题”的解决方案。区块头数据包括区块版本号、前一区块的哈希、交易数据的哈希、时间戳、难度目标值和随机数（Nonce）。
3. 共识算法数据：根据不同的共识算法，您需要处理不同的数据。比如，比特币使用的是工作量证明算法，而以太坊使用的是基于Proof of Stake的共识算法，所需要处理的数据也不同。

需要注意的是，挖矿需要大量的计算资源，因此一般需要使用专门的挖矿设备或者在云平台上租用计算资源。在实践中，大多数人选择加入挖矿池，与其他矿工合作，共同挖掘区块并分享收益。

##### 当一个交易发起后，所有节点都会收到这个交易吗

当一个交易发起后，该交易会被广播到整个区块链网络中的每个节点，因此所有节点都会收到这个交易。

当一个节点收到一个交易后，它会验证该交易的合法性。这个过程通常包括检查该交易是否遵守了区块链协议的规则，以及该交易是否包含有效的数字签名。如果该交易被认为是有效的，该节点将把它添加到其未确认交易池中，并将其广播到网络中的其他节点。

当其他节点收到该交易时，它们会执行相同的验证过程，如果该交易合法，它们也会将其添加到它们自己的未确认交易池中，并将其广播到其他节点。

一旦交易被包含在一个新的区块中并被确认，它将被视为不可逆的，并被视为已完成。在比特币中，一笔交易通常需要被包含在至少6个区块中才会被视为确认，而在以太坊中，一笔交易通常需要被包含在至少12个区块中才会被视为确认。

##### 比特币区块链中，一个区块的哈希值是由哪些参数算得的

具体来说，比特币区块链中一个区块的哈希值是由以下参数计算得到的：

1. 区块版本号（Version）：标识区块所使用的协议版本。
2. 前一个区块的哈希值（Previous Block Hash）：指向前一个区块的哈希值，通过这个参数将区块链接在一起，形成区块链。
3. Merkle 根（Merkle Root）：将区块中包含的所有交易记录经过哈希计算得到一个 Merkle 树，再将 Merkle 树的根节点作为 Merkle 根参数。
4. 时间戳（Timestamp）：记录区块被创建的精确时间，以 Unix 时间戳的形式表示。
5. 难度目标（Bits）：表示区块头哈希值的难度目标，通过这个参数可以调整挖矿难度。
6. 随机数（Nonce）：矿工在挖矿过程中需要不断尝试不同的随机数值，使得区块头的哈希值满足难度目标的要求。

这些参数通过哈希函数（通常使用 SHA-256）进行哈希计算，得到的哈希值就是该区块的唯一标识符。需要注意的是，区块中还包含了其他一些参数，如区块高度、交易数量等，但这些参数并不直接参与哈希计算。

##### 公钥的作用

在区块链系统中，公钥作为密码学的基本工具之一，具有以下几个主要的作用：

1. 数字签名验证：公钥可以用于验证数字签名的有效性。在区块链中，交易和区块都需要经过数字签名验证，以保证其完整性和真实性。发送方使用私钥对交易或区块进行签名，接收方使用对应的公钥来验证签名是否正确。
2. 身份验证：公钥可以用于身份验证。在区块链中，公钥被用作身份的唯一标识。每个用户都有一对公钥和私钥，公钥可以公开，私钥必须保密。当用户在网络上进行交易时，他们需要用自己的私钥对交易进行签名，并将交易广播到网络中。其他节点通过验证签名来确定交易是否来自合法的用户。
3. 密钥交换：公钥可以用于密钥交换。在区块链中，公钥可以被用于协商共享密钥，实现安全的通信。例如，在以太坊智能合约中，合约中的函数可以根据公钥生成一个共享密钥，从而保证只有持有对应私钥的用户可以调用该函数。
4. 地址生成：公钥可以用于生成钱包地址。在比特币和其他加密货币中，钱包地址是由公钥通过一定算法生成的。因此，如果您拥有一个公钥，您就可以通过相应的算法生成一个钱包地址。

总之，公钥在区块链系统中起着重要的作用，保障了系统的安全性和可靠性。



## 4 常见问题

### 4.1 毕业设计的流程

> 1. **选题阶段**
>
>    在这个阶段，你需要确定你的研究方向和主题。选择合适的研究方向和主题将使你的研究更具实际应用价值和科学研究价值。
>
> 2. **需求分析与现状调查阶段**
>
>    在这个阶段，你需要进行市场调查和现状分析，以了解目前区块链在金融领域的应用情况，分析现有的问题和需求。这些分析和调查将为你的研究提供基础数据和关键信息。
> 3. **可行性分析阶段**
>
>    在这个阶段，你需要评估你的研究方案是否可行。这包括评估技术可行性、商业可行性、法律可行性等方面。通过可行性分析，你可以更好地评估你的研究的可行性和可行性。
> 4. **系统设计阶段**
>
>    在这个阶段，你需要确定你的系统架构和技术方案。你需要设计和实现一个功能完整、安全可靠的区块链系统，涉及到区块链技术的多个方面，包括共识机制、存储结构、智能合约、隐私保护等。	
> 5. **开发实现阶段**
>
>    在这个阶段，你需要根据你的设计方案进行系统开发和实现。你需要使用你选择的技术和工具进行开发，将你的系统实现为一个可用的软件产品。
> 6. **测试与优化阶段**
>
>    在这个阶段，你需要进行系统测试和优化。你需要测试你的系统的各个方面，包括功能、性能、安全性等，并对其进行优化和改进，以确保其稳定性和可靠性。
>


### 4.2 毕业论文内容

> 您的毕业论文主要涉及以下内容：
>
> 1. **区块链技术的基本概念和原理**。这部分内容将介绍区块链的基本构成和原理，包括区块、哈希、共识机制等概念，以及区块链的去中心化特点和优势。
> 2. **金融领域中可信系统的研究现状和传统金融系统问题**。这部分内容将介绍金融领域中的可信系统，包括传统的金融交易系统和互联网金融平台，以及它们存在的问题和挑战，如信息不对称、信用风险、数据隐私等方面的问题。
> 3. **区块链技术在金融领域的应用场景**。这部分内容将介绍区块链技术在金融领域中的应用场景，如数字货币、智能合约、供应链金融、股票交易等方面的应用，以及它们解决的问题和优势。
> 4. **区块链技术在金融领域中可信系统的设计与实现**。这部分内容将介绍如何利用区块链技术设计和实现可信的金融系统，包括可信数据的存储和传输、交易的验证和确认、智能合约的编写和执行等方面的问题。
> 5. **区块链技术在金融领域的应用案例和评估**。这部分内容将介绍一些区块链技术在金融领域中的应用案例，如比特币、以太坊、Ripple等项目，以及对它们的技术评估和商业价值分析。
>
> 通过对以上内容的研究，您可以深入理解区块链技术在金融领域中的应用和价值，为未来的金融行业发展提供有益的借鉴和启示。
>



# isMusic项目

## 1 项目概述

### 项目的背景与目的

**背景与目的：**音乐是人类文化的重要组成部分，而随着互联网的发展和普及，音乐分享平台也成为人们分享、发现和交流音乐的主要渠道之一。我们的音乐分享平台以提供高质量、社区氛围良好的音乐分享服务为目标，致力于打造一个用户体验优秀、功能丰富、性能稳定的音乐分享平台。我们使用 SpringBoot 和 Vue 作为开发框架，通过后端Java技术和前端Web技术的结合，实现了丰富的音乐资源管理、搜索、播放功能，同时也具备良好的安全性、稳定性和用户体验。

### 项目的主要部分

1. **需求分析和规划**：收集周边同学对类似平台的需求，并对需求进行分析，设计方案，确定项目的功能需求、性能需求，进而确定技术栈、开发语言和架构等。
2. **总体设计与详细设计**：初期确定了项目的主要功能与设计方案，绘制了用例图、数据流图、ER图等等
3. **数据库设计和开发**：设计和实现数据库模型，建立数据表、字段、索引等。
4. **前端开发和后端开发**：通过Vue框架，使用HTML、CSS和JavaScript等技术实现平台的前端页面和交互功能。使用 SpringBoot 框架，使用Java语言实现平台的后端逻辑和接口功能，同时实现与数据库的交互。
5. **测试和调试**：对平台的前后端逻辑、交互和数据库进行测试和调试，确保平台的稳定性和可靠性。

### 项目的流程

项目流程的具体步骤可以根据项目的具体要求来定义，但一般来说，项目流程可以分为以下几个步骤：

1.**定义项目**：确定项目的目标、范围、投入资源、预期成果、风险等，制定项目计划。

2.**组建项目团队**：根据项目的需要，组织相关的专业人员组成项目团队，明确责任分工。

3.**管理项目**：制定项目管理规范，对项目进行实施和控制，以确保项目按照计划进行。

4.**实施项目**：根据项目计划，按时完成项目的各项工作。

5.**评估项目**：结合项目实施过程，评估项目的效果，追踪项目的变化，并及时做出调整。

6.**结束项目**：归档项目文件，完成项目报告，发表项目成果，做出总结和反思。

### 主要做了哪些工作	

项目分工：测试(1) + 后端(3) + 数据挖掘(1) + 前端(2)

我在本次项目中担任项目负责人，统筹整个项目的规划与组员分工，主要负责项目的整体架构、数据库表设计，完成了JWT用户登录管理模块、Redis数据缓存模块、ES搜索模块以及大部分接口的编写与其功能的实现， 因为自学过一些Vue框架，后期也帮助前端同伴完成了部分页面的开发工作。

### 项目中学习到什么

通过参与这个项目，我深化了对 Spring Boot 框架的理解，并能够更加熟练地编写 Vue 框架下的 JavaScript 代码。在项目中，我们采用了多模块同时开发的思路，这让我对多模块程序架构有了更深刻的理解。

另外，项目环境配置让我更加深入地了解了中间件和分布式系统，尤其是对于 MySQL、Redis、ElasticSearch 和 RabbitMQ 等中间件的使用更加熟悉。作为小组的组长，我通过对组内成员工作任务的分配和产出代码的整合，更加熟练地使用了 Git 等先进的版本控制方式，同时也更深刻地理解了版本控制的重要性，进一步提升了自己的技能水平。

### 合作时遇到的问题

Git 版本控制软件之前没有使用过，在版本更新时之前没有保存的代码被覆盖，最后通过Git恢复操作日志的方式才找回。



## 2 项目难点与解决措施

### 难点一、数据同步

在本项目中使用Mysql作为主数据库，Redis作为缓存中间件，ElasticSearch作为搜索中间件，各个组件之间的数据同步对于我来说就成为了一个问题。

#### Redis 与 Mysql 的数据同步

**项目初期**：我们团队使用的策略是通过代码直接实现 Redis 与 Mysql 的同步增删改，修改 Mysql 中的数据后将最新的数据同步到 Redis中，虽然数据一致性得到保证，但是这种同步策略会导致系统性能受到影响，将操作 Mysql 与 Redis 的代码放入一个模块，代码的耦合度也会更高。

**目前进展**：数据的操作只涉及增删改查，对于增改操作只需要修改 Redis 中的数据，这样查询操作仍然能够查询到最新的数据。而对于删除操作，就优先删除 Mysql 中的数据，随后删除 Redis 的数据。但这样还只是实现了软同步，我们的项目使用了 SpringBoot Schedule 数据包来实现一个定时器，定时在数据访问量较小的时间段将 Redis 中被修改的数据存入硬盘实现硬同步。

**未来展望**：虽然对于现阶段的同步策略对于业务处理速度很快，但由于采用定时器方式数据同步的实时性还是会受影响，在查阅资料后发现，目前主流的同步策略是借助 MySQL 日志 binlog 来实现同步，该同步方式采用异步同步方式，在 MySQL 主库上进行数据变更操作时，并不需要等待同步完成，因此不会对主库的性能造成直接的影响。未来我也将会学习这种同步方法，将该方法运用到项目之中。谢谢老师，我的回答完毕。

### 难点二、团队协作

作为本项目小组的负责人，我深感团队协作不易。

- 人员管理困难：我们的小组包括我共有 7 名成员，团队成员的工作效率、技能水平、合作能力层次不齐。部分组员之前没有接触过某些模块开发工作，对于学习新技术的热情不高，或者是有其他学业上的压力，不愿意投入太多时间等等，这些都对项目的开发进度产生影响。
- 项目进度控制困难：我们小组后端开发成员占多数，前端页面开发工作进度缓慢，以至于后端开发完毕后，后端开发小组一同设计前端。
- 项目合作困难：部分成员对 Git 版本控制工具的使用不熟练，代码合并时惹出了不必要的麻烦。

- 



## 4 常见问题

### 4.1 测试工作如何展开

在我们的项目中，测试工作主要分为三个阶段：**单元测试、集成测试和系统测试**。

首先，后端组员在编写代码的过程中就会进行单元测试，保证代码的正确性和可维护性。我们使用`JUnit`框架进行单元测试，测试时使用白盒测试。

其次，我们在集成阶段进行集成测试。在这个阶段，我们会将各个模块进行集成，并进行**接口测试、性能测试**。我们使用`Postman`进行接口测试，并使用 `JMeter `进行性能测试。

最后，在系统测试阶段，我们会对整个系统进行测试，模拟用户的使用场景，并使用 `JMeter `进行压力测试。

总的来说，我们的测试工作覆盖了各个阶段，并使用了多种测试工具和框架，确保了项目的质量和稳定性。

> **性能测试（Performance Testing）：**是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项[性能指标](https://so.csdn.net/so/search?q=性能指标&spm=1001.2101.3001.7020)进行测试。负载测试和压力测试都属于性能测试。通过负载测试，确定在各种工作负载下的系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。
>
> **负载测试（Load Testing）：**是模拟实际软件所承受的负载条件的系统负荷，通过不断加载（如逐渐增加模拟用户的数量）或其他加载方式来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（CPU、内存等），以检验系统的行为和特性，以发现系统可能存在的性能瓶颈，内存泄漏，不能实时同步等问题，负载测试更多的体现了一种方法或一种技术。
>
> **压力测试（Stress Testing）：**在强负载（大数据量、大量并发用户等）下的测试，查看应用系统在峰值使用情况下的操作行为，从而有效地发现系统的某项功能隐患，系统是否具有良好的容错能力和可恢复能力。压力测试可分为高负载下的长时间（如24小时以上）的稳定性压力测试和极限负载情况下导致系统奔溃的破坏性压力测试。
>
> **三者的区别**： 从测试的目的出发，从用户的需求出发，就比较容易区分性能测试、负载测试和压力测试了。性能测试是为了获得系统在某种特定的条件下（包括特定的负载条件下）的性能指标数据，而负载测试、压力测试是为了发现软件系统中所存在的问题，包括性能瓶颈、内存泄漏等。通过负载测试，也是为了获得系统正常工作时所能承受的最大负载，这时的负载测试就成为了容量测试。通过压力测试，可以知道在什么极限情况下系统会奔溃、系统是否具有自我恢复性等，但更多的是为了确定系统的稳定性。

### 4.2 项目亮点

本次项目中，合理利用了不同中间件的功能，

- Redis缓存：
- 使用了高性能ElasticSearch搜索引擎：

### 4.3 如何搭建消息队列，用消息队列做了什么

在本次项目中使用了 RabbitMQ 充当消息队列，目的是为了实现流量消峰，同时在用户模块与搜索模块之间搭建消息队列，实现应用解耦，通常还可以进行异步处理、应用解耦等功能。



# My_BLOG 项目

## 想法

### 1、使用关键字匹配md文档小标题

### 2、上传的文章勾选图片压缩存储
