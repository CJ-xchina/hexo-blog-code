```
title: 复试计算机组成原理笔记
date: 2023-03-18 00:00:00
tags: 计算机组成原理
categories: 计算机基础学科
keywords:
description: 
top_img:
comments:
cover: https://w.wallhaven.cc/full/1p/wallhaven-1ppld1.jpg
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
```

<meta name="referrer" content="no-referrer"/>

## 计算机系统概述

### 问题一、冯诺依曼机基本思想

> 1. **存储程序**：程序和数据都存储在同一个内存中，计算机可以根据指令集执行存储在内存中的程序。这使得程序具有高度灵活性和可重用性。
> 2. **指令流水线**：将指令分成若干阶段，每个阶段执行不同的操作，可以在同一时刻处理多条指令。这样可以提高计算机的执行效率。
> 3. **二进制数系统**：指令和数据都以二进制的形式存储在设备中，计算机能够通过不同指令周期读取的二进制数据加以区分。
> 4. **存储器层次结构**：计算机系统包含多层存储器，不同层次的存储器提供不同的容量、速度和成本。这种存储器层次结构可以满足不同应用程序对存储器的不同需求。
> 5. **组成**：计算机由处理器、控制器、存储器、输入设备与输出设备组成，其中计算机是以运算器为中心。

### 问题二、计算机指标

> - **字长（机器字长)**：通常指CPU内部能够用于整数运算的数据通路的宽度，反映了计算机处理信息的能力。通常一台机器的字长与通用寄存器的位数相同。
>   - **指令字长**：一条指令中包含的二进制位数，指令字长是存储字长的整数倍。
>   - **存储字长**：一个存储单元内的二进制代码的长度，与MDR的位数相同。
> - **吞吐量**：单位时间内，某一个系统内处理的请求数量
> - **流水线吞吐率**：单位时间内流水线完成任务数量
> - **流水线加速比：**同一批任务，不使用流水线与使用流水线的时间之比。
> - **CPI**：执行一条指令需要的时钟周期数。
> - **MIPS**：每秒执行的指令数量，单位：百万
> - **MFLOPS/GFPLPS/TFLOPS** ：每秒执行的浮点运算次数，单位：百万/十亿/万亿

## 数据的表示

### 问题一、原码，补码，负数补码的转换

**原码 <——> 补码**：从右到左第一个1，这个1左侧的**所有“数值位”**取反。

**补码<——> 负数补码：**从左到右第一个1，这个1左侧的**全部位**取反。

### 问题二、大端存储方式与小端存储方式

数据存储格式：左高右低

大端存储方式：高地址存放在低有效字节（符合人类阅读习惯)

小端存储方式：低地址存放在高有效字节

### 浮点数的表示形式

#### 1、移码

> 移码（又叫增码)是对真值补码的符号位取反，一般用作浮点数的阶码，引入的目的是便于浮点数运算时的对阶操作。
>
> 对于定点整数，计算机一般采用补码的来存储。正整数的符号位为 0，反码和补码等同于原码。负整数符号位为1，原码、反码和补码的表示都不相同，由原码变成反码和补码有如下规则：
> （1)原码符号位为1不变，整数的每一位二进制数位求反得反码；
> （2)反码符号位为1不变，反码数值位最低位加1得补码。
>
> 比如，以一个字节 8bits 来表示 -3，那么 $[ − 3 ] _原 = 10000011$ ，$[ − 3 ]_ 反 = 11111100$，$[ − 3 ] _补 = 11111101$，那么 -3 的移码就是$[ − 3 ] _移 = 01111101$。

#### 2、浮点数的表示

##### 2.1 浮点数的单精度表示

> IEEE754 标准中，一个规格化的 32 位浮点数 x 的真值表示为：
> $$
> x=(-1)^S\times(1.M)\times2^e
> $$
>
> $$
> e = E - 127
> $$
>
> 其中尾数域值是 $1.M$。因为规格化的浮点数的尾数域最左位总是 1，故这一位不予存储，而认为隐藏在小数点的左边。
>
> 在计算指数 e 时，对阶码E的计算采用移码的计算方式，因此 32 位浮点数的 8bits 的阶码 E 的取值范围是 0 到 255。其中当E为全 0 或者全 1 时，是 IEEE754 规定的特殊情况，下文会另外说明。

##### 2.2 浮点数的双精度表示

> 64 位的浮点数中符号为 1 位，阶码域为 11 位，尾数域为 52 位，指数偏移值是 1023。因此规格化的 64 位浮点数 x 的真值是：
> $$
> x=(-1)^S\times(1.M)\times2^e
> $$
>
> $$
> e=E-1023
> $$

#### 3、浮点数的存储方式

> IEEE754 标准中规定 float 单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数，即小数部分。对于 double 双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数，其中指数域称为阶码。IEEE754 浮点数的格式如下图所示。
>
> ![image-20230318213641177](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230318213641177.png)
>
> **注意**，IEE754 规定浮点数阶码 E 采用"**指数ｅ的移码 - 1**"来表示，请记住这一点。为什么指数移码要减去 1，这是 IEEE754 对阶码的特殊要求，以满足特殊情况，比如对正无穷的表示。

#### 4、浮点数的规格化

> 若不对浮点数的表示作出明确规定，同一个浮点数的表示就不是唯一的。例如$（1.75)_{10}$可以表示成 ：$1.11\times2^0,0.111\times2^1,0.0111\times2^2$，等多种形式。
>
> 题目中如果没有说明，那么尾数默认使用原码进行表示：当尾数不为 0 时，**尾数域的最高有效位为1**，这称为<font color='red'>浮点数的规格化</font>。否则，以修改阶码同时左右移动小数点位置的办法，使其成为规格化数的形式。

#### 5、浮点数的特殊表示

> **NaN（非数）**
>
> 31 30             23 22                                                0
>
> ![img](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/2275830-20211015091757616-387066893.png)
>
> 
>
> ![img](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/2275830-20211015091821089-753735360.png)
>
> 

> **无穷大**
>
> 31 30             23 22                                               0
>
> **![img](https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015091843426-307441338.png)**
>
> 无穷用于表达计算中产生的**上溢问题**。比如两个极大的数相乘时，尽管两个操作数本身可以保存为浮点数，但其结果可能大到无法保存为浮点数，必须进行舍入操作。根据IEEE标准，此时不能将结果舍入为可以保存的最大浮点数（因为这个数可能与实际的结果相差太远而毫无意义)，而应将其舍入为无穷。对于结果为负数的情况也是如此，只不过此时会舍入为负无穷，也就是说符号域为1的无穷。

> **非规格化数**
>
> 31 30             23 22                                               0
>
> **![img](https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015091951553-1778330150.png)**
>
> 
>
> **在这种情况下，指数值 E=1-Bias（单精度下即为1-127=-126)，而有效数字的值 M=f，也就是说它是小数段的值，不包含隐含的开头的 1。**
>
> **![img](https://img2020.cnblogs.com/blog/2275830/202110/2275830-20211015092029485-1718188036.png)**

## 指令系统

### 问题一、基址寻址与变址寻址的区别

> **基址寻址（Base Addressing)**是一种寻址方式，它通过将一个基础地址和一个偏移地址相加得到访问的地址。基址寄存器存储基础地址，偏移地址可以是一个常量或者是一个寄存器的值，**基址寻址是面向操作系统的**。基址寻址可以让程序员将程序中的逻辑地址转换为物理地址，从而实现访问内存的功能，有利于多道程序设计。
>
> **变址寻址（Indexed Addressing)**是一种寻址方式，它通过将一个基础地址和一个偏移地址相加得到访问的地址，这个偏移地址是由一个寄存器存储的值加上一个常量得到的，**变址寻址方式是面向用户的**。这种寻址方式适用于随机访问数组，编制循环程序。

### 问题二、RISC 与 CISC 的比较

![image-20230301190304958](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230301190304958.png)

## 中央处理器

### 问题一、指令周期的构成

> 1. **取指周期**：读取PC的值送入MAR中，读取内存中的指令放入MDR后放回IR（指令寄存器)。
> 2. **间址周期**：根据操作数的寻址方式获取操作数的物理地址。
> 3. **执行周期**：取出操作数，执行指令。
> 4. **中断周期**：保护程序断点。

### 问题二、简述一下什么是指令流水线

流水线（pipeline)是一种提高计算机CPU效率的技术，它通过将指令执行过程拆分成多个阶段，让每个阶段可以独立执行，并且在同一时刻可以有多个指令在不同阶段执行，从而提高指令执行的吞吐量和效率。

#### 流水线的冒险

##### 数据冒险（数据冲突)

> - 概念：数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。
> - 解决办法：
>   - **数据旁路技术（转发机制)**：不等前一条指令把计算结果写回寄存器组，下一条指令不再读寄存器组，而是直接把前一条指令的计算结果作为自己的输入数据开始计算过程
>   - **暂停流水线**：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞（stall)和软件插入“NOP”两种方法
>   - **编译优化**：通过编译器调整指令顺序来解决数据相关
>
> **数据冒险的分类**：
>
> - **写后读（RAW)相关**：按序发射，按序完成时，只可能出现 RAW 相关
>
> ```none
> // R5 发生冲突
> I1：ADD R5，R2，R4      （R2)+（R4) -> R5 // 往 R5 写入
> I2：ADD R4，R5，R3      （R5)+（R3) -> R4 // 从 R5 读出
> ```
>
> - **读后写（WAR)相关**：乱序发射，编写程序的时候希望 I1 在 I2 前完成，但优化手段导致 I2 在 I1 前发射
>
> ```none
> // 编译优化后，导致 I2 先执行，I1 后执行，R2 发生冲突
> // 或 I2 可能比 I1 先完成，导致 M 存储的是 （R4)+（R5) 的结果，而不是原本 R2 的值
> I1: STA M，R2           （R2) -> M, M 为主存单元
> I2: ADD R2，R4，R5      （R4)+（R5) -> R2
> ```
>
> - **写后写（WAW)相关**：存在多个功能部件时，后一条指令可能比前一条指令先完成
>
> ```none
> // I2 可能比 I1 先完成，导致 R3 最后存储的是 （R2)*（R1) 的结果，而不是 （R4)-（R5) 的结果
> I1: MUL R3，R2，R1      （R2)*（R1) -> R3
> I2: SUB R3，R4，R5      （R4)-（R5) -> R3
> ```

##### 结构冒险（资源冲突)

> - 概念：由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关
> - 解决办法：
>   - 暂停流水线：后一相关指令暂停一个时钟周期
>   - 资源重复配置：数据存储器 + 指令存储器

##### 控制冒险

> - 概念：当流水线遇到**转移指令和其他改变 PC 值的指令**而造成断流时，会引起控制相关
> - 解决办法：
>   - 转移指令分支预测：简单预测（永远猜 true 或 false)、动态预测（根据历史情况动态调整)
>   - 预取转移成功和不成功两个控制流方向上的目标指令
>   - 加快和提前形成条件码
>   - 提高转移方向的猜准率

---

### 问题三、简述一下指令执行的阶段

> 1. **取指（IF)**：读取指令
> 2. **译码/读寄存器（ID)**：译码 + 读取寄存器中的操作数
> 3. **执行/计算地址（EX)**：执行运算操作或计算地址
> 4. **访存（MEM)**：写回内存
> 5. **写回（WB)**：写回寄存器堆  

### 问题四、什么是指令，什么是程序

指令是计算机处理器的基本操作命令，它们被编码成二进制形式，由计算机硬件执行。每个指令执行一个特定的任务，如加法、比较、跳转等。

一个程序是一组计算机指令的有序序列，通常用来完成某个特定的任务。它是一个编写好的代码文件，可以被编译器或解释器转换为计算机可以执行的指令序列。

## I/O方式

### 程序中断方式

#### 问题一、中断优先级

中断优先级包括**中断响应优先级**与**中断处理优先级**

- **中断响应优先级**：实际 CPU 响应中断请求的先后顺序，由硬件排队器实现，其无法被改变。
- **中断处理优先级**：优先级更高的中断会优先被处理，中断处理优先级可以由中断屏蔽字来改变。

> 【注意】
>
> ​	每一个中断源都有一个**中断请求标记触发器**与**中断屏蔽触发器**
>
> - 中断请求触发器为“1”时，表示中断源有请求
> - 中断屏蔽触发器为“1”时，表示屏蔽该中断源的请求。
>
> 中断屏蔽触发器可以实现：中断处理优先级调整、多重中断。

#### 问题二、CPU响应中断的条件

> 1. 中断源有请求
> 2. CPU 开中断（异常和不可屏蔽中断不受其限制)
> 3. 处于中断周期

#### 问题三、中断过程

一个完整的中断过程包括**中断响应过程**和**中断处理过程**。

##### 中断响应过程

此过程由硬件自动完成，又称为中断隐指令，它并不是一条具体的指令，其过程如下：

- **关中断**：保护断点和转移到中断服务程序的操作必须一气呵成，不能被再次中断。
- **保存断点**：将原程序的断点存入堆栈或主存指定单元。
- **引出中断服务程序**：识别中断源，取出中断服务程序的入口地址并传送给程序计数器（PC)。

###### 注意几个要点

**（1)断点、现场：**

> - 断点信息：指令无法读取的寄存器内容，如 PC、PSW 的内容。发生中断时，它们由<font color='red'>硬件自动完成保护</font>。
> - 现场信息：指令可以读取的寄存器内容，如通用寄存器等。发生中断时，它们由<font color='red'>软件（即程序员)完成保护</font>，通常由中断服务程序中的指令把它们存入堆栈或主存指定单元。

**（2)引出中断服务程序（硬件向量法之中断向量法)的过程：**

> **识别中断源**-->**中断类型号**--（中断向量地址形成部件)-->**中断向量地址**-->**中断向量**-->**中断服务程序入口**

**（3)中断向量地址、中断向量、中断向量法、向量中断：**

> - 中断向量地址：中断向量表的各个表项的地址，即**中断服务程序的指针的指针**（存放中断向量的地址)。
> - 中断向量：中断向量表的各个表项的内容，指向中断服务程序的入口，即**中断服务程序的指针**。
> - 中断向量法：这种中断方法被称为中断向量法。
> - 向量中断：采用中断向量法的中断被称为向量中断。

下面是一张中断向量表：

| 中断向量地址（中断向量的存储地址) | 中断向量（指向中断服务程序的入口) |
| --------------------------------- | --------------------------------- |
| 0000 0000H                        | 1234 5678H                        |
| 0000 0004H                        | 6666 8888H                        |
| 0000 0008H                        | 4567 8901H                        |
| ......                            | ......                            |

##### 中断处理过程

此过程由**中断服务程序（软件)**完成，其过程如下：

- **保护现场和屏蔽字**：保存通用寄存器和状态寄存器的内容。
- **开中断**：允许更高优先级中断请求得到响应，实现中断嵌套。
- **执行中断服务程序**：中断主体部分。
- **关中断**：恢复现场的操作必须一气呵成，不能被再次中断。
- **恢复现场**：恢复原来通用寄存器和状态寄存器的内容。
- **开中断、中断返回**：通过中断返回指令回到原程序断点处，执行该指令时，硬件自动恢复断点信息。

----

### DMA方式

#### DMA 传送过程

**（1)预处理**：

- DMA 控制器（DMAC)接受外设发出的 DMA 请求（外设传送一个字的请求)，并向 CPU 发出总线请求。
- CPU 响应此总线请求，发出总线响应信号，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。

**（2)数据传送**：

- CPU 向 DMA 控制器指明传送数据的主存单元地址及长度，以及数据在主存和外设间的传送方向。
- DMA 控制器发出读写等控制信号，执行数据传送操作。每传送一个数据，自动修改主存地址计数和传送长度计数。

**（3)后处理**：

- DMA 控制器向 CPU 报告 DMA 操作的结束，执行中断服务程序。恢复 CPU 的一切权利。

#### DMA 传送方式

主存和 **<font color='red'>DMA 控制器</font>** 之间有一条数据通路，不通过 CPU。但当 I/O 设备和 CPU
同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方法使用主存：

- **停止 CPU 访问主存**：CPU 处于不工作状态，未充分发挥 CPU 对主存的利用率。
- **DMA 与 CPU 交替访存**：一个 CPU 周期，分为 C1 和 C2 两个周期，C1 专供 DMA 访存，C2 专供 CPU 访存。
- **周期挪用（周期窃取)**：DMA 访存时有三种可能：CPU 此时不访存（不冲突)；CPU 正在访存（存取周期结束让出总线)；CPU 与 DMA 同时请求访存（I/O 访存优先)。

> 【注意】这里的周期指的是**存取周期**！
>
> DMA 控制器：对传送过程进行控制的硬件
>
> DMA、Cache 通道均为硬件

#### DMA 方式与中断方式的比较

| 项目     |                中断方式                | DMA 方式                                          |
| -------- | :------------------------------------: | ------------------------------------------------- |
| 数据传送 | 程序控制（程序的切换-->保存和恢复现场) | 硬件控制（CPU只需进行预处理和后处理)              |
| 中断请求 |                传送数据                | 后处理                                            |
| 响应     |       指令执行周期结束后响应中断       | 每个机器周期结束均可，总线空闲时即可响应 DMA 请求 |
| 场景     |           CPU控制，低速设备            | DMA控制器控制，高速设备                           |
| 优先级   |             优先级低于DMA              | 优先级高于中断                                    |
| 异常处理 |             能处理异常事件             | 仅传送数据                                        |















































































