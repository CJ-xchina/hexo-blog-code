---
title: 软件工程
date: 2023-3-21 18:46:00
tags: 软件工程
categories: 计算机基础学科
keywords:
description:
top_image:
comments:
cover: https://w.wallhaven.cc/full/y8/wallhaven-y8622k.jpg
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---
<meta name="referrer" content="no-referrer"/>



# 软件工程概述

## 软件危机

### 1 什么是软件危机

> **定义**：计算机软件的<font color='red'>**开发**</font>和<font color='red'>**维护**</font>过程所遇到的一系列严重问题。
>
> **表现**：
> （1）对软件开发成本和进度的估算很不准确
> （2）用户很不满意
> （3）质量很不可靠
> （4）没有适当的文档难于维护
> （5）软件成本比重上升
> （6）供不应求：软件开发生产率跟不上计算机应用迅速深入的趋势

### 2 软件危机的原因

> **客观**：软件本身独有的特点确实给开发和维护带来了困难 Ps：逻辑部件、规模庞大、维护数量不断膨胀（软件维护通常意味着改正或修改原来的设计）
>
> **主观**：与软件开发和维护的许多错误认识和做法的形成有关
> Ps：忽视需求分析、认为软件开发=程序编写、轻视软件维护

### 3 如何解决软件危机

> **组织管理**
> 用现代工程的概念，原理，技术和方法进行计算机软件的开发，管理和维护
> （编写程序所需的工作量只占软件开发全部工作量的10%～20%）
> 做好软件定义时期的工作
>
> **技术措施**
> 软件开发技术与方法（例如面向对象技术等）
> 软件工具（例如配置管理工具、测试工具等）

## 软件工程

### 1 软件工程的概念

> **软件工程（Software  Engineering）**是指导计算机软件**开发和维护**的一门学科，采用工程的概念、原理、技术和方法来开发与维护软件。

### 2 软件工程要素、目标和原则

> **软件工程三要素：方法、工具和过程。**
>
> - 方法：提供了“如何做”的技术
> - 工具：提供了自动或半自动的软件支撑环境
> - 过程：将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的
>
> 软件工程的目标可概括为：通过系统化、规范化的方式，将计算机科学的原理、方法和工具应用于软件的开发、维护和演化中，以提高软件开发的效率、质量和可靠性。
> 软件工程的最终目的是摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。

### 3 软件质量定义

> 软件质量是软件特性的综合，指**软件与明确的和隐含地定义的需求相一致的程度**。
>

### 4 软件质量的评测

> 通过以下四个方面进行评估：
>
> - **可靠性**：正确性和健壮
> - **可维护性：**可读性，可修改性，可测试性，完整性
> - **可理解性：**简单性，清晰性，可用性
> - **效率**

## 软件的生命周期

### 问题定义：（需要解决什么问题？）

> 提出应该解决什么问题；

### 可行性研究：（问题是否有行得通的解决方案?）

> 目的：该软件项目是否应该做；
>
> 对软件项目进行多个角度分析；
> 	**技术可行性**：当前技术能否完成该软件项目
> 	**经济可行性**：该项目预估投入多少，能否带来收益
> 	**操作可行性**：该项目是否界面友好，功能清晰，能够方便操作
> 工具：数据流图、系统流程图
> 产物：最终将分析结果以可行性研究报告的形式展现

### 需求分析：（做什么?）

> 目的：了解客户需求，明确客户对软件项目的需求；（做什么）
> 内容：确定用户对软件项目的功能、性能、数据格式、界面的需求；
> 工具：建立逻辑模型、使用数据流图
> 产物：最终将用户需求用**软件需求规格说明书**的形式详细阐述

### 概要设计：（怎么做？大概）

> 目的：完成对软件项目的大概设计；
> 内容：对软件项目的功能模块进行划分，接口、界面的完成
> 产物：概要设计说明书

### 详细设计：（怎么做？详细）

> 目的：完成对软件项目功能实现的详细做法；
> 内容：对功能模块的实现，细化到算法、数据结构的层次，
> 	  详细的定义功能模块的实现；
> 工具：程序流程图、伪代码、PAD图
> 产物：详细设计说明书；

### 编码：（开始做）

> 目的：根据详细设计说明书，选择程序设计语言，完成编码工作；
> 产物：源代码

### 测试：（检查）

> 目的：发现软件项目中尚未发现的问题；
> 方法：
> 	1、黑盒测试：又叫功能性测试，只关注功能是否实现，不关注内部算法；
> 		①、边界值分析	②、等价类划分
> 	2、白盒测试：又叫结构性测试，关注内部算法是否正确；
> 		①、路径覆盖		②、条件覆盖	③、判定覆盖	④、条件组合覆盖
> 		⑤、语句覆盖		⑥、判定条件覆盖
> 	3、灰盒测试：结合白盒测试和黑盒测试，既关注内部逻辑，又关注总终结果
> 阶段：
> 	单元测试---->集成测试---->验收测试---->平行测试
> 	单元测试：单元模块的测试，最小功能模块，是否满足正常需求，错误操作是否会提醒
> 	集成测试：主要目的是检查每个单元模块集成接口的测试；
> 	系统测试：对整体软件系统的功能、性能的测试
> 	验收测试：对软件项目进行交付前的最后测试，对照需求规格说明书和交付标准，
> 			 演示软件项目功能满足用户需求和验收标准；（用户参与、数据真实）
> 	平行运行：新老版本的同时运行，分析处理结果，使用户熟悉新版本
>
> 产物：测试分析报告

### 运行维护（售后服务）

> 目的：保证软件产品交付之后的售后服务，维持软件产品的后期维护和完善工作，
> 	 保证软件铲平能够持续工作
> 分类：
> 	1、正确性维护：发现软件测试阶段未发现的错误，维持软件产品功能的正常运作
> 	2、适应性维护：软件适应信息技术变化和管理需求变化而进行的修改。
> 	3、完善性维护：增加新的系统功能和需求。
> 	4、预防性维护：前瞻性的将一些将来会用到的功能加入到系统中，预防系统被淘汰
> 产物：程序维护手册

## 软件过程

### 1 瀑布模型

> 软件过程：为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。

#### 1.1 定义

**瀑布模型**（Waterfall Model）是一种软件开发生命周期模型，它是最早提出的一种软件开发过程模型，由Winston Royce于1970年提出。**<font color='red'>瀑布模型将软件开发过程划分为多个阶段，每个阶段的结果都是下一个阶段的输入，严格按照流程进行，每个阶段的输出作为下一个阶段的输入。</font>**因此，瀑布模型也被称为“经典生命周期模型”。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304153502690.png" alt="image-20230304153502690" style="zoom:67%;" />



瀑布模型的基本流程，包括需求**分析、设计、编码、测试和维护**等几个阶段，每个阶段的输出作为下一个阶段的输入，从而构成了一个线性的开发流程。

#### 1.2 瀑布模型的特征

| 特点       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 阶段划分   | 将软件开发过程划分为需求分析、设计、编码、测试和运行维护等几个阶段，每个阶段都有特定的目标和输出。 |
| 线性流程   | 每个阶段严格按照顺序进行，下个阶段必须等待上个阶段结束，上一个阶段的输出是下一个阶段的输入。 |
| 阶段交付物 | 每个阶段都有特定的交付物，比如需求文档、设计文档、编码实现等，这些交付物都需要经过审核、验收等过程。 |
| 难以回溯   | 由于每个阶段都是线性的，因此难以回溯到前面的阶段进行修改和调整，容易导致重复工作和浪费时间和资源。 |

#### 1.3 瀑布模型的优缺点

- **优点**：瀑布模型适用于需求明确、稳定性高的软件开发项目，例如传统的信息系统开发。
- **缺点**：
  - 由于其线性流程的特点，因此在开发初期需要花费大量的时间和精力进行前期规划和需求分析，如果需求变更频繁，则会导致项目延期和成本增加。
  - 由于瀑布模型难以回溯，因此需要对需求和设计进行充分的讨论和确认，以避免后期修改和调整。

---

### 2 快速原型模型

#### 2.1 定义

**快速原型模型**是一种软件开发模型，其主要思想是**<font color='red'>快速构建一个可用的“软件原型”，并根据用户的反馈和需求逐步完善和改进软件。</font>**快速原型模型通常用于需求不明确或难以准确定义的项目，以及需要快速验证软件可行性和功能性的项目。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/827c6ce3e63649bca2f0df30a621d827.png" referrerpolicy="no-referrer" alt="在这里插入图片描述">

> ps：图中的实线为开发过程，虚线为软件维护过程

#### 2.2 快速原型模型的特征

| 特征     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 快速性   | 快速原型模型的主要特点是能够快速开发出可行的原型，并进行测试和评估。它不仅能够节省时间和成本，还能够提高项目的成功率。 |
| 用户参与 | 快速原型模型强调用户的参与和反馈，能够帮助团队更好地理解用户需求，从而开发出更符合用户需求的产品。 |
| 迭代性   | 快速原型模型是一个迭代的过程，软件产品一旦交付给用户使用后，维护便开始了。 |
| 灵活性   | 快速原型模型比传统的瀑布模型更加灵活，能够根据实际情况进行调整和改变，从而更好地适应项目的需求和变化。 |

---

### 3 增量模型

#### 3.1 定义

**增量模型**是一种软件开发过程模型，<font color='red'>**它将软件系统分成多个独立的功能模块，并采用逐步添加新的功能模块的方式进行开发**</font>。在增量模型中，每个增量都是一个完整的软件系统，它包含了新增的功能模块以及之前已经开发完成的模块，从而分批次地分析、设计、编码和测试这些增量组件。

增量模型的第一个增量模块往往实现软件的基本需求，提供最核心的功能。

![image-20230303212149564](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230303212149564.png)

#### 3.2 增量模型特征

| 特征                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 分阶段开发             | 采用分阶段开发方法，将整个软件开发过程分为多个阶段，每个阶段的开发成果都可以被使用和测试 |
| 每个增量都是完整的系统 | 每个增量包含了一个或多个功能模块，可以独立运行，是一个完整的系统 |
| 模块化                 | 增量模型采用模块化设计，可以让开发人员对系统进行分解，每个模块都可以独立地进行开发和测试 |
| 迭代式开发             | 每个增量都可以看做是一个迭代，开发人员可以根据需求逐步添加新的功能，完善系统 |
| 风险控制               | 增量模型采用了风险控制的方法，每个增量都是一个可测试的产品，可以及时发现和解决问题 |

#### 3.3 增量模型的优缺点

- 优点：
  - 自第一个构件交付起，用户便可使用软件做一定量的工作，能够向用户在较短时间内提供可完成部分工作的产品是增量模型的优点。
  - 逐步增加产品功能有助于用户更好地适应软件。
- 缺点：没一个新增的构件加入到系统中，之前已经加入的构件均不能被修改，这必须把软件结构设计地便于按这种方式进行扩充，增加了开发难度。

---

### 4 螺旋模型

#### 4.1 定义

螺旋模型是一种风险驱动的软件开发过程模型，在项目开发过程中，风险无处不在，项目越大，软件越复杂，承担该项目的风险也就越大。在快速原型模型中曾提到了“软件原型”的概念，而螺旋模型的基本思想，就是使用原型以及其他方法来降低风险，**可以将其视为每一个阶段之前都添加风险分析过程的原型模型与瀑布模型的结合，螺旋模型适合大型项目的开发。**

每次迭代中都会包含计划、风险分析、工程实现和评审四个阶段，每个迭代周期结束后都会进行回顾和评估，并在此基础上制定下一轮的计划。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20191213122139497.png" alt="在这里插入图片描述" style="zoom: 44%;" />

#### 4.2 螺旋模型的优缺点

优点：

- 强调风险管理，能够减少项目失败的风险。
- 适用于大规模、复杂、安全性要求高的软件开发。
- 建立在早期原型开发和增量式开发的基础上，能够更好地满足客户的需求。

缺点：

- 适用范围相对较窄，不适合小规模的软件开发。
- 需要更多的风险评估和管理，对项目管理能力要求高。
- 开发成本相对较高。

----

### 5 喷泉模型

#### 5.1 定义

喷泉模型（fountain model）是一种**以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程**。各个阶段使用统一的概念和表示方法，生命周期各阶段无缝连接（面向对象方法在概念和表示方法上的一致性，保证了各项开发活动之间的无缝连接)。

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/d2ac5c4eff44410ea75d9ba20b7a2dc5.jpeg" alt="img" style="zoom:50%;" />

#### 5.2 喷泉模型的优缺点

**优点：**

- 喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发可以提高软件项目开发效率，节省开发时间适应于面向对象的软件开发过程。

**缺点：**

- 由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，因此不利于项目的管理。
- 喷泉模型要求严格管理文档，使得审核的难度加大尤其是面对可能随时加入的各种信息、需求与资料的情况。

#### 5.3 适用场景

面向对象开发

### 6 敏捷过程

敏捷过程由下面 4 个简单的价值观声明而成：

1. 个体和交互胜过过程和工具
2. 可以工作的软件胜过了面面俱到的文档
3. 客户合作胜过合同谈判
4. 响应变化胜过遵循计划

### 7 极限编程

极限编程之所以能在采用它的企业中获得成功，是因为它高度强调客户满意。这种方法并不尝试一次交付所有可能在遥远的将来用到的功能，而是在真正需要时交付最有价值的软件。极限编程使软件开发者满怀信心地响应客户的需求变化，哪怕在交付项目的后期也同样如此。

极限编程强调团队协作。在一支高度协同的团队中，管理者、客户、开发者都是平等的合作伙伴。极限编程营造了简单而有效的协作环境，使团队最大程度地发挥其生产力。团队自发地组织起来，尽可能高效地解决问题。

**极限编程从五个方面提升软件项目：沟通、简单、反馈、尊重、勇气**

- 实践极限编程的程序员持续不断地与客户和其他程序员**沟通**。
- 他们保持设计**简单**整洁。
- 他们从项目第一天起就对软件做测试，从测试中获得**反馈**。
- 他们尽可能早把系统交付给客户使用，**尊重**客户提出修改意见的权利。
- 他们小步前进，每一次小的成功都会增进团队成员彼此之间的**尊重**与信任。
- 在前面这些的基础上，极限编程的实践者们方有**勇气**积极响应不断变化的需求和技术。

# 可行性研究

## 1 可行性研究的目的

可行性研究的目的就是<font color='red'>**用最小的代价在尽可能短的时间内确定问题是否能够解决**</font>。必须分析几种解法的利弊，从而判断原定的系统目标和规模是否现实，系统完成后所能带来的效益是否大到值得投资开发这个系统的程度。

一般说来，至少应该从以下三个方面研究每种解法的可行性：

- **技术可行性**：使用现有的技术能否实现这个系统

- **经济可行性**：这个系统的经济效益能否超过它的开发成本

- **操作可行性**：这个系统的操作方式在客户组织内是否行得通。

## 2 系统流程图(SFD)

### 2.1 概念

**系统流程图（System Flowchart）：**是描绘系统物理模型的传统工具。它的基本思想是用图形符号以黑盒子形式描绘系统里面的每个部件(程序、文件、数据库、表格、人工过程等），表达信息在各个部件之间流动的情况和系统的操作控制。

### 2.2 系统流图符号定义

![img](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20190423090657322.png)

就机房收费系统为例，系统流程图如下：

![img](https://img-blog.csdnimg.cn/2019042309024470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjcyNDQ2Nw==,size_16,color_FFFFFF,t_70)

## 3 数据流图(DFD)

### 3.1 数据流图基本概念

<font color='red'>**数据流图 (Data Flow Diagram，DFD)**</font> 是一种图形化技术，**它描绘信息流和数据从输入移动到输出的过程中所经历的变换。**

> **数据流图的优点**：
>
> 1. 在数据流图中没有任何具体的物理元素，它只是描绘信息在软件中流动和被处理的情况。
> 2. 因为数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，所以是分析员与用户之间极好的沟通工具。
> 3. 设计数据流图时只需考虑系统必须完成的基本逻辑功能，完全不需考虑怎样具体地实现这些功能，因此，它也是今后进行软件设计很好的出发点。
> 4. 数据流图可以在任何抽象层次上被用来表示系统或软件。事实上，数据流图可以被分层次地画，层次越低（在数据流图中1层比0层的层次更等）表现出的信息流细节和功能细节也越多。数据流图既提供了功能建模机制、也提供了信息流建模机制
>

### 3.2 数据流图的基本符号

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304165426558.png" alt="image-20230304165426558" style="zoom:60%;" /><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230304170305326.png" alt="image-20230304170305326" style="zoom: 50%;" />

数据流图有4种基本符号：

- 正方形（或立方体）表示数据的源点或终点；
- 圆角矩形（或圆形）代表变换数据的处理；
- 开口矩形（或两条平行横线）代表数据存储；
- 箭头表示数据流，即特定数据的流动方向。

### 3.3 数据流图案例

#### 示例1：工厂订单报表

假设一家工厂的<font color='orange'>采购部</font>每天需要一张<font color='green'>订货报表</font>，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据:零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为<font color='green'>事务</font>，通过放在<font color='orange'>仓库</font>中的CRT终端把事务报告给<font color='red'>订货系统</font>。当某种零件的库存数量少于库存量临界值时就应该再次订货。

------

##### 数据流图有4种成分分析

**数据流图有4种成分：源点和终点、处理、数据存储和数据流。画出上述定货系统的数据流图可采用以下步骤。**

1. **首先考虑数据的源点和终点**，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的终端把事务报告给订货系统”，所以**采购员是数据终点，而仓库管理员是数据源点**。
2. **接下来考虑处理**。再一次阅读问题描述，“采购部需要报表”，显然他们还没有这种报表，因此必须有一个用于**产生报表的处理**。事务的后果是改变零件库存量，而任何改变数据的操作都是处理，因此，**对事务进行的加工是另一个处理**。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。
3. **最后考虑数据流和数据存储**。系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配：每当有一个事务发生时立即处理它，然而每天只产生一次订货报表，因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储（存储着订货报表的数据，每当订货报表的数据有更新时，可以立即获取最新的订货报表的数据，这样就可以实现每当有一个事务发生时立即处理它）。

**注意，并不是所有数据存储和数据流都能直接从问题描述中提取出来。例如，“当某种零件的库存数量少于库存量临界值时就应该再次订货”，这个事实意味着必须在某个地方有零件库存量和库存量临界值这样的数据。因为这些数据元素的存在时间看来应该比单个事务的存在时间长，所以认为有一个数据存储保存库存清单数据是合理的。**

下表列出了上面分析的结果，其中加星号标记的是在问题描述中隐含的成分。

![在这里插入图片描述](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/046af817fbf24923a43b2d557a5336f7.png)

------

##### 开始画数据流图

一旦把数据流图的4种成分分离出来后，就可以着手画数据流图了。但是要注意，数据流图是系统的逻辑模型，而任何计算机系统实质上都是信息处理系统，也就是说计算机系统本质上都是把输入数据变换成输出数据。因此，任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能。

------

###### 顶层数据流图

对于上述的定货系统可以画出下图所示的顶层数据流图（**突出表明了数据的源点和终点**）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3ba3eb7c6f744b85b9f21bdfd5adb35f.png)
从**顶层数据流图**这样非常高的抽象层次开始画数据流图是一个好办法。在这个高层次的数据流图上是否列出了所有给定的数据源点 / 终点是一目了然的，因此它是很有价值的沟通工具。

------

###### 第0层数据流图

**顶层数据流图**太抽象了，从这张图上所能了解到的信息非常有限。**下一步应该把基本系统模型细化，描绘系统的主要功能。**

由于 “产生报表” 和 “处理事务” 是该系统必须完成的两个主要功能，它们将代替图顶层数据流图中的“订货系统”。此外，细化后的数据流图中还增加了两个数据存储：处理事务需要“库存清单”数据；产生报表和处理事务在不同时间，因此需要存储“定货信息”。除了2.1节（2.1 数据流图有4种成分分析）的表中列出的两个数据流之外还有另外两个数据流，它们与数据存储相同。这是因为从一个数据存储中取出来的或放进去的数据通常和原来存储的数据相同，也就是说，数据存储和数据流只不过是同样数据的两种不同形式（事务 <–> 库存清单，订货信息 <–> 订货报表）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a2052e7924284f6bb1b9bcbfe0d47318.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

给处理和数据存储都加了编号，这样做的目的是便于引用和追踪。

------

###### 第1层数据流图

接下来应该对功能级数据流图中描绘的系统主要功能进一步细化。考虑通过系统的逻辑数据流，当发生一个事务时必须首先接收它；随后按照事务的内容修改库存清单；最后如果更新后的库存量少于库存量临界值时，则应该再次定货，也就是需要处理定货信息。因此，把“处理事务”这个功能分解为下述3个步骤：“接收事务”、“更新库存清单”和“处理订货”，这在逻辑上是合理的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f99b95acfa87410b8dd19b99b7baffc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

我们为什么不进一步分解“产生报表”这个功能呢？因为订货报表中需要的数据在存储的订货信息中全都有，产生报表只不过是按一定顺序排列这些信息，再按一定格式打印出来。然而这些考虑纯属具体实现的细节，不应该在数据流图中表现。同样道理，对“接收事务”或“更新库存清单”等功能也没有必要进一步细化。**总之，当进一步分解将涉及如何具体地实现一个功能时，就不应该再分解了。**

在对数据流图分层细化时必须保持信息连续性，即当把一个处理分解为一系列处理时，分解前和分解后的输入/输出数据流必须相同。

还应该注意在数据流图中对处理进行编号的方法。处理1.1，1.2和1.3是更高层次的数据流图中处理1的组成元素。如果处理2被进一步分解，它的组成元素的编号将是2.1， 2.2……如果把处理1.1进一步分解，则将得到编号为1.1.1，1.1.2……的处理，以此类推。

------

##### 补充: 数据流图命名规范

数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。
因此，给这些成分起名字时应该仔细推敲。

数据源点/终点并不需要在开发目标系统的过程中设计和实现，它并不属于数据流图的核心内容，只不过是目标系统的外围环境部分（可能是人员、计算机外部设备或传感器装置）。通常，为数据源点 / 终点命名时采用它们在问题域中习惯使用的名字（如“采购员”、“仓库管理员”等）。

> 数据流（或数据存储）命名：

- 名字应代表整个数据流（或数据存储）的内容，而不是仅仅反映它的某些成分。
- 不要使用空洞的、缺乏具体含义的名字（如“数据”、“信息”、“输入”之类）。
- 如果在为某个数据流（或数据存储）起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。

> 处理命名：

- 通常先为数据流命名，然后再为与之相关联的处理命名。这样命名比较容易，而且体现了人类习惯的“由表及里”的思考过程。
- 名字应该反映整个处理的功能，而不是它的一部分功能。
- 名字最好由一个具体的及物动词加上一个具体的宾语组成。应该尽量避免使用“加工”、“处理”等空洞笼统的动词作为名字。
- 通常名字中仅包括一个动词。如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。
- 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。

------

#### 练习1：教务管理子系统

教务管理是一项需求周密计划、严谨安排的工作，要依据教师、学生信息进行合理安排。

> 教务管理子系统的需求描述：

- 开学阶段，需要<font color='orange'>教师</font>提交开课<font color='green'>申请进行开课</font>，<font color='orange'>学生</font>根据老师的开课信息，选择课程，教务处生成学生课表、教师课表。
- 期末阶段，需要根据开课情况对学生进行<font color='green'>考试安排</font>，对教师进行监考安排，以及学生考试成绩管理。
- 学期结束，需要对学生<font color='green'>成绩进行统计</font>，计算绩点，排名，评定奖学金。

------

##### 3.1.1 顶层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/b693d6634fd64aa0818998909107e3b8.png)

------

##### 3.1.2 第0层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/ee6a029c391942eb9fc7ecfd068f450b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

##### 3.1.3 第1层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/fbc808338f7a4d82aea313ec8ed66199.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

#### 练习2：图书馆管理子系统

> 图书馆管理子系统的需求描述：

- 借书过程，学生到图书馆查询图书信息，出示借书证，办理借书。
- 还书过程，判断是否超期、图书是否破损，办理还书。

------

##### 3.2.1 顶层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/54860f267be143d89fd82576ad269695.png)

------

##### 3.2.2 第0层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/64977ac1055b421a9d8f279bf14fef20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

##### 3.2.3 第1层数据流图

![在这里插入图片描述](https://img-blog.csdnimg.cn/8c804676bdae447b93e038c9131b266f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZUppYW8=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

### 3.4. 补充：数据流图的附加符号

![在这里插入图片描述](https://img-blog.csdnimg.cn/ec85e3bc664f4ac4a46c79370b9d27e7.png)

- `*` 表示数据流之间是“**与**”关系（同时存在）
- `+` 表示“**或**”关系
- ⊕ 号表示只能从中选一个（互斥的关系）

注意：这里的圆形可以被圆角矩形框替换，都表示变换数据的处理。
![在这里插入图片描述](https://img-blog.csdnimg.cn/dbca1c655f3a46378595c4aac37f8f26.png)

------

### 3.5. 说明：顶层数据流图和0层的关系

![在这里插入图片描述](https://img-blog.csdnimg.cn/2760f84930c74d7da4c70f70fc5d0579.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/35b86392754745c391922b2fcf973114.png)

- **顶层数据流图只含一个加工表示整个系统**
- **0层数据流图是对父层数据流图中某个加工进行细化，它的某个加工也可以再次细化，形成子图，层次的多少，一般视系统的复杂程度而定。**

## 4 数据字典

### 4.1 数据字典的概念

> **数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。**任何字典最主要的用途是供人查阅对不了解的条目的解释，数据字典的作用也正是在软件分析和设计的过程中给人提供数据的描述信息。数据流图和数据字典共同构成系统的逻辑模型。

**数据字典的内容：**

| **一般信息** | **名字，别名，描述**                                         |
| ------------ | ------------------------------------------------------------ |
| **定义**     | **数据类型，长度，结构**                                     |
| **使用特点** | **值的范围，使用频率，使用方式（输入，输出，本地，条件值等）** |
| **控制信息** | **来源，用户，使用它的程序，改变劝，使用权等**               |
| **分组信息** | **父结构，从属结构，物理位置（记录，文件和数据库等）**       |

**定义数据的方法：**

| **方法** | **符号** | **解释**                             |
| -------- | -------- | ------------------------------------ |
| **顺序** | **+**    | **以确定顺序连接两个或多个分量**     |
| **选择** | **[  ]** | **从两个或多个可能的元素中选取一个** |
| **重复** | **{  }** | **把指定的分量重复零次或多次**       |
| **可选** | **(  )** | **一个分量是可有可无的**             |

### 4.2 数据字典举例

**数据项**：数据的最小单位。其具体内容包括：数据项名、含义说明、别名、类型、长度、取值范围、与其他数据项的关系。

| **数据项名** | 选课单号           |
| ------------ | ------------------ |
| **说明**     | 表示每张选课单     |
| **类型**     | CHAR(8)            |
| **长度**     | 8                  |
| **别名**     | 选课号             |
| **取值范围** | 000000001-99999999 |

**数据结构**：数据项有意义的集合。内容包括：数据结构名、含义说明，这些内容组成数据项名

| **数据结构名** | 考试课程                                                     |
| -------------- | ------------------------------------------------------------ |
| **说明**       | 作为考场安排的组成部分，说明某门课程哪位老师代，以及所选学生人数。 |
| **组成**       | 课程号、教师号、选课人数                                     |

**数据流**：可以是数据项，也可以是数据结构，它表示某一处理过程中数据在系统内传输的路径。内容包括：数据流名、说明、流出过程、流入过程，这些内容组成数据项或数据结构。

| **数据流名** | 考场安排                                         |
| ------------ | ------------------------------------------------ |
| **说明**     | 由各课程所选学生数，选定教师、时间、安排考场     |
| **来源**     | 考场                                             |
| **去向**     | 教师                                             |
| **数据结构** | 考场安排（考试课程、考试时间、教学楼、教师编号） |

**数据存储**：处理过程中数据的存放场所，也是数据流的来源和去向之一。可以是手工凭证，手工文档或计算机文件。

| **数据存储名** | 课程表                                         |
| -------------- | ---------------------------------------------- |
| **说明**       | 对每门课程的名称、学分、先行课程号和摘要描述。 |
| **输出数据流** | 课程介绍                                       |
| **数据描述**   | 课程号、课程名、学分数、先行课程号、摘要       |
| **数目**       | 每年500种                                      |
| **存取方式**   | 随机存取                                       |

处理过程：处理过程的处理逻辑通常用判定表或判定树来描述，数据字典只用来描述处理过程的说明性信息。

| **处理过程** | 选课                                                         |
| ------------ | ------------------------------------------------------------ |
| **说明**     | 对要选某门课程的每一个学生，根据已选修课程 确定其是否可选该课程。再根据学生选课的人数选择适当的教室，制定选课单。 |
| **输入**     | 学生选课、可选课程、已选课程                                 |
| **输出**     | 选课单                                                       |
| **程序提要** | a. 对所选课程在选课表中查找其是否已选此课程b. 若未选过此课程，则在选课表中查找是否已选此课程的先行课程c. 若a、b都满足，则在选课表中增加一条选课记录d. 处理完全部学生的选课处理后，形成选课单 |

## 5 成本和效益分析

### 5.1 成本估计技术

1. **代码行技术** 
2. **任务分解技术** 
3. **自动估计成本技术**

### 5.2 成本效益分析方法

1. **货币的时间价值** 
2. **投资回收期** 
3. **纯收入** 
4. **投资回收率**

# 需求分析

## 1 需求分析概述

### 1.1 什么是需求分析

> <font color='red'>**需求分析**</font>是指开发人员要准确地理解用户的要求，进行细致的调查研究，**将用户非形式化的需求描述转化为完整的需求定义，再由需求定义转化为相应的[软件需求规格说明书](https://www.omegaxyz.com/2019/07/23/software-specification/)（即需求分析的结果）的过程**。
>
> 需求分析之前还不确定系统怎样完成它的工作，**而仅仅是确定系统必须完成哪样工作，也就是对目标系统提出完整，准确，清晰，具体的要求。**

### 1.2 需求分析的基本任务

> 需求分析可以概括为下面四个任务：
>
> - **确定对系统的综合要求**
> - **分析系统的数据要求**
> - **导出系统的逻辑模型**
> - **修正系统的开发计划**

#### 1.2.1 确定系统的综合要求

| <font color='red'>**需求**</font>                          | <font color='red'>**描述**</font>                            |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| <font color='cornflowerblue'>**功能需求**</font>           | **系统必须提供的服务**                                       |
| <font color='cornflowerblue'>**性能需求**</font>           | **系统必须满足的定时约束或容量约束，通常包括速度，速率，主存容量，磁盘容量等** |
| <font color='cornflowerblue'>**可靠性和可用性需求**</font> | **可靠性需求定量地指出系统的可靠性可用性与可靠性密切相关，它量化了用户可以使用系统的程度** |
| <font color='cornflowerblue'>**出错处理需求**</font>       | **说明系统对环境错误应该怎样响应**                           |
| <font color='cornflowerblue'>**接口需求**</font>           | **接口需求描述应用系统与它的环境通信的格式**                 |
| <font color='cornflowerblue'>**约束**</font>               | **设计约束或实现约束在设计或实现应用系统时应遵守的限制条件，精度，工具，语言，设计约束等** |
| <font color='cornflowerblue'>**逆向需求**</font>           | **说明软件系统不应该做什么，理论上有无限个逆向需求**         |
| <font color='cornflowerblue'>**将来可能提出的要求**</font> | **应该明确列出那些虽然不属于当前系统开发范畴，但根据分析很可能会提出来的要求** |

#### 1.2.2 分析系统的数据要求

> （1）任何一个系统软件本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响，因此，必须分析系统的数据要求，这是软件需求的一个重要任务。
>
> （2）复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观，为了提高可理解性，常常利用<font color='orange'>**图形工具**</font>辅助描绘数据结构。
>
> （3）软件系统经常使用各种长期保存的信息，这些信息通畅以一定方式组织并存储在数据库或者文件中，为减少数据冗余，避免出现插入异常或删除异常，简化修改数据的过程，通常需要把数据结构规范化。

#### 1.2.3 导出系统的逻辑模型

> 综合上述两项分析结果可以导出系统的详细的逻辑模型，通常用<font color='orange'>数据流图</font>，<font color='orange'>实体-联系图(E-R)</font>，<font color='orange'>状态转换图</font>，数据字典和主要的处理算法描述这个逻辑模型。

#### 1.2.4 修正系统开发计划

> 根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划

## 2 获取需求的方法

### 2.1 访谈

> | <font color='red'>正式访谈</font>       | 系统分析员将提出一些事先准备好的具体问题                     |
> | --------------------------------------- | ------------------------------------------------------------ |
> | <font color='red'>**非正式访谈**</font> | **分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法** |
>
> **在访问用户的过程中使用<font color='corn'>情景分析技术</font>往往非常有效。所谓情景分析就是对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。**
>
> **情景分析的用处：**
>
> - **它能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。**
> - **由于情景分析较易为用户所理解，使用这种技术能保证用户在需求分析过程中始终扮演一个积极主动的角色。**

### 2.2 面向数据流自顶向下求精

> **结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法。**通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。
>
> 为了达到这个目标，通常从数据流图的输出端着手分析，这是因为系统的基本功能是产生这些输出，输出数据决定了系统必须具有的最基本的组成元素。
>
> 数据流图是帮助复查的极好工具，从输入端开始，分析员借助数据流图、数据字典和IPO图向用户解释输入数据是怎样一步一步地转变成输出数据的。这些解释集中反映了通过前面的分析工作分析员所获得的对目标系统的认识。
>
> 随着分析过程的进展，经过提问和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的满意了解。
>
> ![img](https://img-blog.csdnimg.cn/20201019161158118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)

### 2.3 简易的应用规格说明技术

> 简易的应用规格说明技术是为了解决使用传统的访谈或面向数据流自顶向下求精方法定义需求时，用户处于被动地位而且往往有意无意地与开发者区分“彼此”。由于不能像同一个团队的人那样齐心协力地识别和精化需求，这两种方法的效果有时并不理想的，	
>
> ![img](https://img-blog.csdnimg.cn/20201019161340883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)

### 2.4 快速建立软件模型

> 特性：
>
> - 快速原型应该具备的第一个特性是“快速”。
>
> - 快速原型应该具备的第二个特性是“容易修改”。
>
> 方法工具：
>
> - 第四代技术：数据库查询和报表语言，程序和应用系统生成器以及其他非常高级的非过程语言。
> - 可重用的软件构件：用已有的软件构建来装配原型。
> - 形式化规格说明和原型环境：将形式化语言翻译成可执行的程序代码。

## 3 分析建模

### 3.1 什么是模型

> **模型：**就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。通常，模型由一组图形符号和组织这些符号的规则组成。

### 3.2 （E-R）实体-联系图

#### 3.2.1 E-R 图的概念

**E-R**图也称**实体-联系图(Entity Relationship Diagram)**，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型**。它属于数据库设计中概念结构设计的一部分，反映了用户需求。**

> - <font color='red'>实体（entity）</font>即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象。
> - <font color='red'>属性（attribute）</font>即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性。属性分为唯一属性（键）与其他，唯一属性（键）就好比学生id,其他则是年龄、性别等不能唯一表示实体的属性。
> - <font color='red'>联系（relationship）</font>用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系。
>

#### 3.2.2 实体间的联系分类

> - 1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系。 如，一个学校只有一个正校长。
> - 1对多（1:N）：1对多关系是指实体集A与实体集B中至少有N(N>0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。
>   如多个学生选修同一门专业，则专业与学生关系则是1对多。
> - 多对多（M:N）：对于两个实体集A和B，若A中每一个实体值在B中有多个实体值与之对应，反之亦然，则称实体集A与实体集B具有多对多联系。如一个部门有多个员工，一个员工也可在多个部门任职。因此，员工与部门的工作关系为多对多。
>

#### 3.2.3 ER图表现形式

<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230305105748624.png" alt="image-20230305105748624" style="zoom: 67%;" />

- 矩形框：表示实体，填入实体名
- 菱形框：表示联系，填入联系名，联系连接两个实体，联系的出入两边填入实体间的联系。
- 椭圆形框：表示实体或联系的属性，框内填入属性名。对于主属性名，如id，在其下方画下划线
- 连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。如

#### 3.2.4 ER图举例

一个学生可选修多门课，一门课有若干学生选修；
一个教师可讲授多门课，一门课只有一个教师讲授；
一个学生选修一门课，仅有一个成绩。
学生的属性有学号、学生姓名；教师的属性有教师编号，教师姓名；课程的属性有课程号、课程名。

**答案：**
<img src="https://img-blog.csdnimg.cn/00b7d5b1ea3e41938239e2cbe9af3c9c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA77mP6IG95rW3,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 80%;" />



## 3 数据规范化

### 3.1 第一范式

每个属性都是原子值，仅仅是个简单值不含内部结构，很好理解。

### 3.2 第二范式

**在第一范式的基础上，所有的非主属性完全依赖于主键，完全依赖意味着不能依赖于主键的一部分属性。**

反例：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215032997.png)

对于该表，学号和课程号组合在一起是主键，但是姓名只由学号决定，违反了第二范式。类似还有课程名由课程号决定。

所以应该拆分为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215110451.png)

### 3.3 第三范式

第三范式的条件：满足第二范式的基础上，**非主属性都不传递依赖于主键，即一个非关键字属性值不依赖于另一个非关键字属性。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215150687.png)

主键是学号，但是学校地址也可以由学校名称决定，存在传递依赖

分解为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215219145.png)

> **完全函数依赖**
>
> 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ’ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方，没办法打出来……，正确的写法如）
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201010151000478.png#pic_center)
>
> 例如： 学号 F→ 姓名 （学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）
>
> 
>
> **部分函数依赖**
>
> 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201010151118924.png#pic_center)
>
> 例如：（学号，课名） P→ 姓名
>
> 
>
> **传递函数依赖**
>
> 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X ，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020101015134156.png#pic_center)



## 4 状态转换图

状态转换图（[状态图](https://so.csdn.net/so/search?q=状态图&spm=1001.2101.3001.7020)）： 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。状态图还指明了作为特定事件的结果系统将做哪些动作，因此状态图提供了行为建模机制。

### 4.1 状态和事件

> - **状态**：状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个或一系列动作，也可以是仅仅改变系统本身的状态，还可以是即改变状态又做动作。    在状态图中定义的状态主要有：初态（初始状态）、终态（最终状态）、中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。
>
> - **事件**：事件是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另一个状态的外界事件的抽象。事件是引起系统做动作或（和）转换状态的控制信息

### 4.2 符号

​    ![img](https://img-blog.csdnimg.cn/2509d9f6df854c93ac91562f7e6ed09f.png)

### 4.3 举例

​    ![img](https://img-blog.csdnimg.cn/d72c4cf2c560441eaa55c53bd8e875b8.png)

## 5 验证软件需求

### 5.1 从哪些方面验证软件需求的正确性

> 1. **一致性**：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
> 2. **完整性**：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或 性能。
> 3. **现实性**：指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。对硬件技术的进步可以做些预测，对软件技术的进步则很难做出预测，只能从现有技术水平出发判断需求的现实性。
> 4. **有效性**：必须证明需求是正确有效的，确实能解决用户面对的问题。
>

# 总体设计

> <font color='red'>**总体设计**</font>的基本目的就是回答“**概括地说，系统应该如何实现**”这个问题，因此，总体设计又称为概要设计或初步设计。
>
> 总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。

## 1 总体设计过程

> ![img](https://img-blog.csdnimg.cn/20201021144641438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201021144422875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 1，**<font color='red'>设想供选择的方案</font>**：在总体设计阶段分析员应该考虑各种可能的实现方案，并且力求从中选出最佳方案。需求分析阶段得出的数据流图是总体设计的极好的出发点。设想供选择的方案的一种常用的方法是，设想把数据流图中的处理分组的各种可能的方法，抛弃在技术上行不通的分组方法(例如，组内不同处理的执行时间不相容)，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。
>
> 2，**<font color='red'>选取合理的方案</font>**：应该从前一步得到的一系列供选择的方案中选取若干个合理的方案，通常至少选取低成本、中等成本和高成本的3种方案。在判断哪些方案合理时应该考虑在问题定义和可行性研究阶段确定的工程规模和目标，有时可能还需要进一步征求用户的意见。
>
> 对于每个合理方案，分析员都应该准备下列4份材料：（1）系统流程图（2）组成系统的物理元素清单（3）成本/效益分析（4）实现这个系统的进度计划
>
> 3，**<font color='red'>推荐最佳方案</font>**：用户和有关的技术专家应该认真审查分析员所推荐的最佳系统，如果该系统确实符合用户的需要，并且是在现有条件下完全能够实现的，则应该提请使用部门负责人进一步审批。在使用部门的负责人也接受了分析员所推荐的方案之后，将进入总体设计过程的下一个重要阶段——结构设计。
>
> 4，**<font color='red'>功能分解</font>**：为了最终实现目标系统，必须设计出组成这个系统的所有程序和文件(或数据库)。对程序(特别是复杂的大型程序)的设计，通常分为两个阶段完成：首先进行结构设计，然后进行过程设计。为确定软件结构，首先需要从实现角度把复杂的功能进一步分解。分析员结合算法描述仔细分析数据流图中的每个处理，如果一个处理的功能过分复杂，必须把它的功能适当地分解成一系列比较简单的功能。
>
> 5，**<font color='red'>设计软件结构</font>**：通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能，每个下层模块再调用更下层的模块，完成程序的一个子功能，最下层的模块完成最具体的功能。
>
> 6，**<font color='red'>设计数据库</font>**：对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。
>
> 7，**<font color='red'>制定测试计划</font>**：在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。
>
> 8，**<font color='red'>书写文档</font>**：应该用正式的文档记录总体设计的结果，在这个阶段应该完成的文档通常有：（1）系统说明；（2）用户手册；（3）测试计划（测试策略，测试方案，预期的测试结果，测试进度计划）；（4）详细的实现计划；（5）数据库设计结果；
>
> 9，**<font color='red'>复查和复审</font>**：最后应该对总体设计的结果进行严格的技术审查，在技术审查通过之后再由客户从管理角度进行复审。

## 2 设计原理

### 2.1 模块化-面向对象

> <font color='red'>**模块**</font>**是由边界元素限定的相邻程序元素（例如，数据说明，可执行的语句）的序列，而且有一个总体标识符代表它。模块是构成程序的基本构件。**
>
> <font color='red'>**模块化**</font>**就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。**
>
> 模块化是为了使一个复杂的大型程序能被人的智力所管理，是软件应该具备的唯一属性。
>
> ```scss
> 设函数C(x)定义问题x的复杂程度，函数E(x)确定解决问题x需要的工作量(时间)。
> 对于两个问题P1和P2，如果C(P1)>C(P2),E(P1)>E(P2)
> 根据人类解决一般问题的经验，会出现：C(P1+P2)>C(P1)+C(P2)
> 那么可以得出：E(P1+P2)>E(P1)+E(P2)
> ```
>
> **把复杂的问题分解成许多容易解决的小问题，原来的问题也就容易解决了——这就是模块化的根据。**

> 如果无限地分割软件，最后为了开发软件而需要的工作量也就小得可以忽略了。事实上，还有另一个因素在起作用，从而使得上述结论不能成立。
>
> **当模块数目增加时每个模块的规模将减小，开发单个模块需要的成本(工作量)确实减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。根据这两个因素，得出了总成本曲线。每个程序都相应地有一个最适当的模块数目M，使得系统的开发成本最小。**
>
> ![img](https://img-blog.csdnimg.cn/20201021151351185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 虽然目前还不能精确地决定M的数值，但是在考虑模块化的时候总成本曲线确实是有用的指南。
>
> 采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解。模块化也有助于软件开发工程的组织管理，一个复杂的大型程序可以由许多程序员分工编写不同的模块，并且可以进一步分配技术熟练的程序员编写困难的模块。

### 2.2 抽象

> 人类在认识复杂现象的过程中使用的最强有力的思维工具是抽象。人们在实践中认识到，在现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。或者说**<font color='red'>抽象</font>就是抽出事物的本质特性而暂时不考虑它们的细节**。
>
> 在抽象的最高层次使用问题环境的语言，以概括的方式叙述问题的解法；在较低抽象层次采用更过程化的方法，把面向问题的术语和面向实现的术语结合起来叙述问题的解法；最后，在最低的抽象层次用可以直接实现的方式叙述问题的解法。
>
> 软件工程过程的每一步都是对软件解法的抽象层次的一次精化：
>
> - 在可行性研究阶段，软件作为系统的一个完整部件；
> - 在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的；
> - 当由总体设计向详细设计过渡时，抽象的程度也就随之减少了；
> - 最后，当源程序写出来以后，也就达到了抽象的最低层。

### 2.3 逐步求精

> 逐步求精定义为为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是一种自顶向下的设计策略。按照这种设计策略，程序的体系结构是通过逐步精化处理过程的层次而设计出来的。通过逐步分解对功能的宏观陈述而开发出层次结构，直至最终得出用程序设计语言表达的程序。
>
> 求精实际上是细化的过程；抽象与求精是一队互补的概念。

### 2.4 信息隐藏和局部化

> 信息隐藏原理：应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。如果在测试期间和以后的软件维护期间需要修改软件，使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。
>
> 局部化是指把一些关系密切的软件元素物理地放得彼此靠近。

### 2.5 模块独立

> 模块独立的重要性：
>
> - 有效的模块化(即具有独立的模块)的软件比较容易开发出来。
> - 独立的模块比较容易测试和维护。
>
> 模块独立性可以由两个定性标准度量：耦合和内聚

#### 耦合

> <font color='red'>**耦合**</font>**是对一个软件结构内不同模块之间互连程度的度量。耦合强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。**
>
> | 数据耦合     | 两个模块彼此间通过参数交换信息，而且交换信息仅仅是数据。数据耦合是低耦合，系统中至少必须存在这种耦合。 |
> | ------------ | ------------------------------------------------------------ |
>| 控制耦合     | 传递的信息中有控制信息（尽管有时这种控制信息以数据的形式出现）控制耦合是中等程度耦合。 |
> | 特征耦合     | 当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。 |
>| 公共环境耦合 | 当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。只有两个模块有公共环境，耦合有下面两种可能。(1) 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。(2) 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 |
> | 内容耦合     | 一 个模块访问另一个模块的内部数据。一个模块不通过正常入口而转到另一个模块的内部。两个模块有一部分程序代码重叠 ( 只可能出现在汇编程序中 ) 。一个模块有多个入口 ( 这意味着一个模块有几种功能 ) 。最高程度的耦合，应该坚决避免使用。 |
>
> 尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。

#### 内聚

> <font color='red'>**内聚**</font>是衡量一个模块内部各个元素彼此结合的紧密程度。内聚标志着一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。
>
> 内聚分为三大类低内聚、中内聚和高内聚
> 
>1. **低内聚**
> 
>2. - 一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做**偶然内聚**。
>    - 一个模块完成的任务在逻辑上属于相同或相似的一类，则称为**逻辑内聚**。
>   - 一个模块包含的任务必须在同一段时间内执行，就叫**时间内聚**。
> 
> 3. **中内聚**
> 
> 4. - 一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为**过程内聚**。
>    - 模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为**通信内聚**。
> 
>5. **高内聚**
> 
>6. - 一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行(通常一个处理元素的输出数据作为下一个处理元素的输入数据)，则称为**顺序内聚**。
>    - 模块内所有处理元素属于一个整体，完成一个单一的功能，则称为**功能内聚**。功能内聚是**最高程度的内聚**。
>
> ![img](https://img-blog.csdnimg.cn/20201021161451331.png)
> 
> 事实上，没有必要精确确定内聚的级别。重要的是设计时高内聚，并且能够辨认出低内聚的模块，有能力通过修改设计提高模块的内聚程度并且降低模块间的耦合程度，从而获得较高的模块独立性。

## 3 启发规则

> 1，改进软件结构提高模块独立性：设计出软件的初步结构以后，应该审查分析这个结构，通过模块分解或合并，力求降低耦合提高内聚。
>
> 2，模块规模应该适中：一个模块的规模不应过大，最好能写在一页纸内(通常不超过60行语句)
>
> 3，深度、宽度、扇出和扇入都应适当
>
> - 深度：软件结构中控制的层数
> - 宽度：软件结构内同一个层次上的模块总数的最大值
> - 扇出：一个模块直接控制(调用)的模块数目
> - 扇入：一个模块被多少个上级模块直接调用的数目
>
> ![img](https://img-blog.csdnimg.cn/20201021165628971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201021165658959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 4，模块的作用域应该在控制域之内
>
> - 作用域：受该模块内一个判定影响的所有模块的集合。
> - 控制域：模块本身以及所有直接或间接从属于它的模块的集合。
>
> ![img](https://img-blog.csdnimg.cn/20201021165844169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201021165847392.png)
>
> 5，力争降低模块接口的复杂程度：模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。
>
> 6，设计单入口单出口的模块：这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。
>
> 7，模块功能应该可以预测：模块的功能应该能够预测，但也要防止模块功能过分局限。反例：模块使用全局变量或是静态变量，则可能导致不可预测。

## 4 描绘软件结构的图形工具

### 4.1 层次图和HIPO图

> <font color='red'>**层次图**</font>**用来描绘软件的层次结构。数据结构的层次方框图相同，但是表现的内容却完全不同。层次图很适于在自顶向下设计软件的过程中使用。**
>
> ![img](https://img-blog.csdnimg.cn/20201021210331329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> - 层次图表示的层次为软件的结构而非数据结构
> - **层次图每个矩形所代表的是一个模块，连线所表示的是“调用”而非“组成”。**
> - 层次图是调用关系，层次方框图是组成关系。

### 4.2 结构图

> <font color='red'>**结构图**</font>是进行软件结构设计的工具
>
> ![img](https://img-blog.csdnimg.cn/2020102121063216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> | 方框           | 模块，框内注明模块的名字或主要功能 |
> | -------------- | ---------------------------------- |
> | 方框之间的箭头 | 模块的调用关系                     |
> | 空心圆         | 传递的是数据                       |
> | 实心圆         | 控制信息                           |

## 5 面向数据流的设计方法

### 5.1 基本概念

> 面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法。
>
> ![img](https://img-blog.csdnimg.cn/37c4c5ffffe4463583b819f6cf7e34f2.png)
>
> | 变换流                                         | 信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫作变换流。 |
> | ---------------------------------------------- | ------------------------------------------------------------ |
> | 事务流                                         | 数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划为一类特殊的数据流，称为事务流。 |
> | 当信息流有明显的“发射中心”时，可以归结为事物流 |                                                              |
>
> 设计过程
>
> ![img](https://img-blog.csdnimg.cn/20201021211302268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)

### 5.2 变换分析（例子）

> 变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构。
>
> 例子 ：汽车数字仪表板的设计，假设的仪表板将完成下述功能。
>
> - 通过模数转换实现传感器和微处理机接口。
> - 在发光二极管面板上显示数据。
> - 指示每小时英里数(mph)，行驶的里程每加仑油行驶的英里数(mpg)等。
> - 指示加速或减速。
> - 超速警告：如果车速超过55英里/小时，则发出超速警告铃声。
>
> （1）复查基本系统模型：复查的目的是确保系统的输入数据和输出数据符合实际。
>
> （2）复查并精化数据流图：应该对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。
>
> ![img](https://img-blog.csdnimg.cn/20201021211739908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201021212616311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （3）去诶定数据流图具有变化特性还是事务特性：一般来说，一个系统中的所有信息流都可以认为是变换流，但是当遇到明显事务特性的信息流时，建议采用实务分析方法进行设计。在这一步，设计人员应该根据数据流图中占优势的属性，确定数据流的全局特性。
>
> （4）确定输入流和输出流的边界，从而孤立出变换中心。
>
> （5）完成“第一级分解”：分解就是分配控制的过程。对于变换流的情况，数据流图被映射成一个特殊的软件结构，这个结构控制输入、变换和输出等信息处理过程。
>
> ![img](https://img-blog.csdnimg.cn/20201021212748492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （6）完成“第二级分解”：从变换中心的边界开始逆着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块；然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块；最后把变换中心内的每个处理映射成受Ct控制的一个模块。
>
> ![img](https://img-blog.csdnimg.cn/20201021212858748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201021212901363.png)
>
> ![img](https://img-blog.csdnimg.cn/20201021212904838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （7）使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。
>
> ![img](https://img-blog.csdnimg.cn/20201021212948615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)

> 事务分析：事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。由事务流映射成的软件结构包括一个接收分支和一个发送分支。
>
> 设计优化
>
> - 在不考虑时间因素的前提下开发并精化软件结构。
> - 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程(算法)，以求提高效率。
> - 使用高级程序设计语言编写程序。
> - 在软件中孤立出那些大量占用处理机资源的模块。
> - 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率。

# 详细设计

> <font color='red'>**根本目标**</font>：**确定应该怎样具体地实现所要求的系统。**
>
> **详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。**
>
> **详细设计的结果基本上决定了最终的程序代码的质量。**

## 1 结构程序设计

### 1.1 结构程序设计的定义

程序的质量与程序中所包含的GO TO 语句的数量成反比。只用“顺序”、“选择”和“循环”控制结构就能实现任何单入口单出口的程序，但也不是完全不适用 GOTO 语句，最好是在检测出错误时才是用GOTO.

<font color='red'>**结构程序设计**</font>是处理详细设计中采用的一种典型的方法，**所使用的结构由<font color='red'>顺序、条件、重复</font>3种控制结构进行连接。实现单入口、单出口，且无死循环、死语句的程序。**

### 1.2 五种基本控制结构

> 顺序型
>
> 选择型
>
> 先判定型循环（Do-While)
>
> 后判定型循环(Do-Until)
>
> 多情况选择型(CASE型）

![在这里插入图片描述](https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/20190601171635132.png)

---

## 2 人机界面设计

> 人机界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，因此，必须对人机界面设计给与足够的重视。

### 2.1 设计问题

> | 系统响应时间 | 系统响应时间指从用户完成某个控制动作到软件给出预期的响应系统响应时间有两个重要属性：（1）长度：时间过长，用户就会感到紧张，过短，加快用户操作节奏，可能会犯错误（2）易变性：系统响应时间相对于平均响应时间的偏差即使系统响应时间较长，响应时间易变性低也有助于用户建立起稳定的工作节奏。 |
> | ------------ | ------------------------------------------------------------ |
> | 用户帮助设施 | 常见的帮助设施可分为集成的和附加的两类：（1）集成的：设计在软件里面，Word的帮助（2）附加的：联机用户手册，jdk手册解决问题：（1）在用户与系统交互期间，是否在任何时候都能获得关于系统任何功能的帮助信息?有两种选择：提供部分功能的帮助信息和提供全部功能的帮助信息。（2）用户怎样请求帮助?有3种选择：帮助菜单，特殊功能键和HELP命令。（3）怎样显示帮助信息?有3种选择：在独立的窗口中，指出参考某个文档(不理想)和在屏幕固定位置显示简短提示。（4）用户怎样返回到正常的交互方式中?有两种选择：屏幕上的返回按钮和功能键。（5）怎样组织帮助信息?有3种选择：平面结构，信息的层次结构和超文本结构。 |
> | 出错信息处理 | 出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。一般说来，交互式系统给出的出错信息或警告信息，具有下述属性：（1）用用户可以理解的术语描述问题。（2）提供有助于从错误中恢复的建设性意见。（3）指出错误可能导致哪些负面后果(例如，破坏数据文件)，以便用户检查是否出现了这些问题，并在确实出现问题时及时解决。（4）伴随着听觉上或视觉上的提示（5）不能带有指责色彩，不能责怪用户。 |
> | 命令交互     | 许多高级用户仍然偏爱面向命令行的交互方式在提供命令交互方式时，必须考虑下列设计问题。（1）是否每个菜单选项都有对应的命令?（2）采用何种命令形式?有3种选择：控制序列(例如，Ctrl+P)，功能键和输入命令。（3）学习和记忆命令的难度有多大?忘记了命令怎么办?（4）用户是否可以定制或缩写命令?在越来越多的应用软件中，人机界面设计者都提供了“命令宏机制”。在理想的情况下，所有应用软件都有一致的命令使用方法。 |

### 2.2 设计过程

> 用户界面设计是一个迭代的过程，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进行修改。
>
> 建立起用户界面的原型，就必须对它进行评估，评估可以是非正式的也可以使正式的。
>
> 用户界面的评估周期 
>
> ![img](https://img-blog.csdnimg.cn/20201023164226867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 评估标准
>
> （1）系统及其界面的规格说明书的长度和复杂程度，预示了用户学习使用该系统所需要的工作量。
>
> （2）命令或动作的数量、命令的平均参数个数或动作中单个操作的个数，预示了系统的交互时间和总体效率。
>
> （3）设计模型中包含的动作、命令和系统状态的数量，预示了用户学习使用该系统时需要记忆的内容的多少。
>
> （4）界面风格、帮助设施和出错处理协议，预示了界面的复杂程度及用户接受该界面的程度。

### 2.3 人机界面的设计指南

> 一般交互指南：涉及信息显示、数据输入和系统整体控制。
>
> | 保持一致性                               | 菜单选择，命令输入，数据显示等应该使用一致的格式             |
> | ---------------------------------------- | ------------------------------------------------------------ |
> | 提供有意义的反馈                         | 应向用户提供视觉的和听觉的反馈，保证在用户和系统之间建立双向通信 |
> | 在执行有较大破坏性的动作之前要求用户确认 | 如果用户要删除某些重要文件，提供再次确认按钮                 |
> | 允许取消绝大多数操作                     | 提供撤销和恢复功能，避免用户浪费大量时间                     |
> | 减少在两次操作之间必须记忆的信息量       | 不需要用户记住下一步操作中需要的数字或字符串                 |
> | 提高对话、移动和思考的效率               | 应尽量减少用户按键的次数，设计屏幕布局应考虑鼠标移动距离     |
> | 允许犯错误                               | 系统能够保护自己不受严重错误的破坏                           |
> | 按功能对动作分类，并据此设计屏幕布局     | 设计者应该尽力提高动作的内聚性                               |
> | 提供对用户工作内容敏感的帮助设施         | 提高用户手册或者在线帮助                                     |
> | 用简单动词或动词短语作为命令名           | 过长的命令难于识别和记忆，也会占用更多的菜单空间             |
>
> 信息显示指南：多种不同方式“显示”信息：用文字、图形和声音；按位置、移动和大小；使用颜色、分辨率和省略。
>
> | 只显示与当前工作内容有关的信息                               | 用户在获得有关系统的特定功能的信息时，不必看到与之无关的数据，菜单和图形。 |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 不要用数据淹没用户，应该用便于用户迅速吸取信息的方式来表示数据 | 可以用图形或图表来取代庞大的表格                             |
> | 使用一致的标记、标准的缩写和可预知的颜色                     | 限制的含义应该非常明确，用户无需参照其他信息源就能理解       |
> | 允许用户保持可视化的语境                                     | 如果对显示的图形进行缩放，原始的图像应该一直显示着，以使用户知道当前看到的图像在原图像中所处的位置 |
> | 产生有意义的出错信息                                         | 提供给用户反馈机制                                           |
> | 使用大小写、缩进和文本分组以帮助理解                         | 人机界面显示的信息大部分都是文字，文字的布局和形式对用户从中提取信息的难易程度有很大影响 |
> | 使用窗口分隔不同类型的信息                                   | 利用窗口用户能够方便地保存多种不同类型的信息                 |
> | 使用“模拟”显示方式表示信息，以使信息更容易被用户提取         | 通过颜色代表数字表示危险程度更能引起用户注意                 |
> | 高效率地使用显示屏                                           | 使用多窗口时，应该有足够的空间使得每个窗口至少都显示出一部分 |
>
> 数据输入指南：用户的大部分时间用在选择命令、输入数据和向系统提供输入。
>
> | 尽量减少用户的输入动作                             | 最重要的是减少用户击键次数，使用滑迟或者语音识别等     |
> | -------------------------------------------------- | ------------------------------------------------------ |
> | 保持信息显示和数据输入之间的一致性                 | 显示的视觉特征（长宽，文字大小）应该与输入域一致       |
> | 允许用户自定义输入                                 | 专家级用户可能希望定义自己的专用命令或忽略类型的警告等 |
> | 交互应该是灵活的，并且可调整成用户最喜欢的输入方式 | 秘书可能喜欢键盘，经理更喜欢鼠标                       |
> | 使在当前动作语境中不适用的命令不起作用             | 使用户不去做那些一定会错误的动作                       |
> | 让用户控制交互流                                   | 用户应该能够逃过不必要的动作，改变动作顺序             |
> | 对所有输入动作都提供帮助                           | 提供输入格式提示                                       |
> | 消除冗余的输入                                     | 提供默认值或者取消数据单位，提供自动获得或者计算       |



## 3 过程设计工具

### 3.1 程序流程图

#### 3.1.1 程序流程图定义

> **程序流程图=程序流程+图**

简单来说，就是**一种描述程序流向的图形**。一般由处理框、判断框、起止框、连接点、流程线、注释框等元素构成。

百度百科对它是这么定义的：

> <font color='red'>**程序流程图**</font>又称程序框图，是用统一规定的标准符号描述程序运行具体步骤的图形表示。 程序框图的设计是在处理流程图的基础上，通过对输入输出数据和处理过程的详细分析，将计算机的主要运行步骤和内容标识出来。

#### 3.1.2 程序流程图的符号

以下是程序流程图常用的几个标准符号：

![img](https://img-blog.csdnimg.cn/img_convert/1b269a05f6f87cb0d6b39af1a9c9aa61.png)

- **循环的标准结构**

![img](https://img-blog.csdnimg.cn/img_convert/dc9578956a58fa73052567f481d7f87f.png)

- **注解符号的使用**

![img](https://img-blog.csdnimg.cn/img_convert/54dc82c59758c017d8d912fec964c0d5.png)

#### 3.1.3 程序流程图常见结构

**顺序型：**几个连续的处理步骤依次排列构成

![img](https://img-blog.csdnimg.cn/img_convert/a54b3bd6cfa3d1ca25c772f2c0c600cd.png)

**选择型：**由某个逻辑判断式的取值决定选择两个处理中的一个

![img](https://img-blog.csdnimg.cn/img_convert/3426a073beb7ac010fcbc0786c5adf15.png)

**先判定（while）型循环：**在循环控制条件成立时，重复执行特定的处理

![img](https://img-blog.csdnimg.cn/img_convert/c3cb9ce45c418e7631c43a24d70fe21e.png)

**后判定（until）型循环：**重复执行某些特定的处理，直至控制条件成立

![img](https://img-blog.csdnimg.cn/img_convert/5fe4a29d89f009772966a049ce74bc24.png)

**多情况（case）型选择：**列举多种处理情况，根据控制变量的取值，选择执行其一

![img](https://img-blog.csdnimg.cn/img_convert/de2c6a6412c304dfdce904367f5837bf.png)

### 3.2 盒图(N-S)

#### 3.2.1 顺序结构

所有语句顺序执行，先执行A后执行B

![img](https://img-blog.csdnimg.cn/img_convert/149e73f8deecc08c9376e8b123789f4c.png)

#### 3.2.2 选择结构

**1）条件结构**

如果条件P成立，执行A，否则执行B

![img](https://img-blog.csdnimg.cn/img_convert/4e141d97cabb204647f8dad50e16659b.png)

**2）多分支选择结构**

P=1的时候，执行A1，P=2的时候，执行A2，依次类推；

![img](https://img-blog.csdnimg.cn/img_convert/3eca3135d3f3bc8910f5ad07a737d224.png)

 

#### 3.2.3 循环结构

**1）当型循环结构**

先判断后执行，当P1条件成立的情况下，反复执行A语句，直到P1条件不成立为止

![img](https://img-blog.csdnimg.cn/img_convert/fcda6efaa39564deaafe7c85b2064214.png)

**2）直到型循环结构**

先执行后判断，当P1条件不成立的情况下，反复执行A语句，直到P1条件成立为止

![img](https://img-blog.csdnimg.cn/img_convert/87c6b119e663fc504219930b0a14bfd0.png)

### 3.3 PAD图

#### 3.3.1 PAD图基本符号

(a) 顺序；(b) 选择；(c) CASE多分支；(d) WHILE型循环； (e) Do-UNTIL型循环；(f) 语句标号；(g) 定义 

<img src="https://img-blog.csdnimg.cn/dde0d839c5e24163b11c072fe7546b43.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

#### 3.3.2 PAD图的应用

 1.请根据下列伪码画出对应的PAD图。

```cobol
GET(a[1],a[2],...a[10]);
max=a[1];
max2=a[2];
FOR i=2 TO 10
IF a[i]>max
max2=max;
max=a[i];
ELSE
IF a[i]>max2
max2=a[i]
ENDIF
ENDIF
ENDFOR
PUT(max,max2)
END
```

![img](https://img-blog.csdnimg.cn/0b59c226e6f94ac1aecfec938cde9648.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 2.请根据下列伪码画出对应的PAD图。

```cobol
定义变量:i=7,S=0
DO WHILE i<=1000
IF(i被7整除)
THEN
S=S+i
输出:i
ENDIF
i=i+1
ENDDO
输出:S
```

![img](https://img-blog.csdnimg.cn/caf5a6b631b54b578fadd45d9420d23a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 3.将下列N-S图转换为PAD图

![img](https://img-blog.csdnimg.cn/5f073eb390c3466f85f33155fd56148f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_7,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/7543940e159641bda3596290ed9d6835.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16) 4.将下列N-S图转换为PAD图

 ![img](https://img-blog.csdnimg.cn/faedd57142fc4ee39100359f3681d964.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_8,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/340e84facea1430a84f129c676b29d65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)



### 3.4 判定表与判定树

#### 3.4.1 判定表与判定树的概念

判定表与[判定树](https://so.csdn.net/so/search?q=判定树&spm=1001.2101.3001.7020)是一种列表设计工具，常用于条件嵌套的复杂判定情况的分析与设计，以及多分支结构代码的设计与实现。

（1）判定表

判定用来描述一些不易用语言表达清楚或需要很大篇幅才能用语言表达清楚的加工逻辑。在某些数据处理问题中，其数据流程图的处理需要依赖于多个逻辑条件的取值，这些取值的组合可能构成多种不同情况，相应地需要执行不同的动作。这种问题用结构化语言来叙述很不方便，使用判定表或判定树作为表示加工说明的工具是最合适的。 一个判定表由四个部分组成，如表5.1所示。

![img](https://img-blog.csdnimg.cn/184e04ab006d415c975f53742c51e2cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树      

判定树是用一种树图形方式来表示多个条件、多个取值所应采取的动作。判定树分支表示各种不同的条件，随着分支层次结构的扩充，各条件完成自身的取值。判定树的叶子给出应完成的动作。

#### 3.4.2 判定表与判定树的应用

细化学生成绩的奖励条件：学生每学期已修课程成绩的比率。优秀比率占70%以上，并且中以下所占比率小于15%，而且表现优良的学生可以获得一等[奖学金](https://so.csdn.net/so/search?q=奖学金&spm=1001.2101.3001.7020)，表现一般的学生可以获得二等奖学金；优秀比率占70%以上，中以下所占比率小于20%，表现优良的学生可以获得二等奖学金，表现一般的学生可以获得三等奖学金；中以下所占比率小于20%，表现优良的学生可以获得三等奖学金，表现一般的学生可以获得四等奖学金。请用判定表与判定树表达上述计算方案。

（1）判定表

![img](https://img-blog.csdnimg.cn/a22218eb3a854385b6922ee2e81f0b24.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树

![img](https://img-blog.csdnimg.cn/92c8172e26f84aa2afe531ddf956e559.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_14,color_FFFFFF,t_70,g_se,x_16) 

2.某校的课酬计算方案如下：(l)基本课酬为每节课10元；(2)如果班级人数超过40人，课酬增加：基本课酬×0.1；(3)如果班级人数超过60人，课酬增加：基本课酬×0.2；(4)如果教师是副教授，课酬增加：基本课酬×0.1；(5)如果教师是教授，课酬增加：基本课酬×0.2；(6)讲师，课酬不增加；(7)助教，课酬减少：基本课酬×0.1。请用判定表达上述计算方案。

![img](https://img-blog.csdnimg.cn/5ce6194afc9941e5b96b509df03997e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

3. 某高校研究生招生系统的初选方法如下：总分300（含）以上进入候选学生库，否则退档数学分数不低于70分，则进入三级备选库，否则进入四级备选库：在三级备选库的基础上，如果专业课分数高于100分，则进入一级备选库，否则进入二级备选库，请画出对应的判定表与判定树。

（1）判定表 

![img](https://img-blog.csdnimg.cn/b3abef7407904033a3d36555ab53932a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_18,color_FFFFFF,t_70,g_se,x_16)

（2）判定树![img](https://img-blog.csdnimg.cn/4934db126cf44c46a73b38eb070f6827.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

4.用判定表与判定树描述检查定货单的处理逻辑：“如果金额超过1000元而又未过期，则发出批准单和提货单。如果金额超过2000元，但已过期，则不发出批准单和提货单。如果金额低于2000元，则不论是否过期，都发出批准单和提货单，而且对低于2000元已过期的还需发出通知单。

（1）判定表 

![img](https://img-blog.csdnimg.cn/ac32b751b1f94c3ab1c4b7b38cbd9d13.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_15,color_FFFFFF,t_70,g_se,x_16)

（2）判定树![img](https://img-blog.csdnimg.cn/99b625d64a574c92b37681543d806eb7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

5.某厂对部分职工重新分配工作的政策是：年龄在20岁以下者，初中文化程度脱产学习。高中文化程度当电工；年龄在2040岁之间者，中学文化程度男性当钳工，女性当车工，大学文化程度都当技术员。年龄在40岁以上者中学文化程度当材料员，大学文化程度当技术员。请用判定表与判定树描述上述问题的加工逻辑 。

判定条件取值

![img](https://img-blog.csdnimg.cn/16e206941e464b52ade7a41771680435.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

 （1）判定表

![img](https://img-blog.csdnimg.cn/67dd1288e6574d10bc71baab9eae52ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16)

（2）判定树

![img](https://img-blog.csdnimg.cn/07466b2f33a54fcaa9f1e7530993c4a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5p2h5bCP5qmY54yr,size_20,color_FFFFFF,t_70,g_se,x_16) 

## 4 面向数据结构的设计方法

> 计算机软件本质上是信息处理系统，可以按照软件所处理的信息的特征来设计软件。
>
> 面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。

### 4.1 Jackson图

> <font color='red'>**顺序结构**</font>：每个元素按照顺序进行执行。
>
> <font color='red'>**选择结构**</font>：选择结构包括两个或多个数据元素，每次使用这个数据时按照一定条件从数据元素中选择一个。
>
> <font color='red'>**重复元素**</font>：根据使用时的条件由一个数据元素出现零次或多次构成。
>
> ![img](https://img-blog.csdnimg.cn/20201023200256365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> **Jackson图优点**
>
> - 便于表示层次结构，而且是对结构进行自顶向下分解的有力工具。
> - 形象直观可读性好。
> - 既能表示数据结构也能表示程序结构。

### 4.2 改进的Jackson图

> **Jackson图的缺点**：用这种工具表示选择或重复时，选择条件或循环条件不能直接在图中表示，影响表达能力。
>
> ![img](https://img-blog.csdnimg.cn/20201023200729553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （a）顺序结构，B、C、D中任一个都不能是选择出现或重复出现的数据元素(即不能是右上角有小圆圈或星号标记的元素)
>
> （b）选择结构，S右面括号中的数字i是分支条件的编号；
>
> （c）可选结构，A或者是元素B或者不出现；
>
> （d）重复结构，循环结束条件的编号为i。

### 4.3 Jackson法

> 步骤：
>
> （1）分析并确定输入数据和输出数据的逻辑结构，并用Jackson图描绘这些数据结构。
>
> （2）找出输入数据结构和输出数据结构中有对应关系的数据单元。
>
> （3）用下述3条规则从描绘数据结构的Jackson图导出描绘程序结构的Jackson图。
>
> - 为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框。
> - 根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。
> - 根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。
> - 列出所有操作和条件(包括分支条件和循环结束条件)，并且把它们分配到程序结构图的适当位置。
> - 用伪码表示程序。
>
> | 顺序结构 | A seq  B  C  DA end                              |
> | -------- | ------------------------------------------------ |
> | 选择结构 | A select cond1 B A or cond2 C A or cond3 D A end |
> | 重复结构 | A iter until(或while) cond B A end               |

> 例子：Jackson结构程序设计：一个正文文件由若干个记录组成，每个记录是一个字符串。要求统计每个记录中空格字符的个数，以及文件中空格字符的总个数。要求的输出数据格式是，每复制一行输入字符串之后，另起一行印出这个字符串中的空格数，最后印出文件中空格的总个数。
>
> （1）分析并确定输入数据和输出数据的逻辑结构，并用Jackson图描绘这些数据结构。
>
> （2）找出输入数据结构和输出数据结构中有对应关系的数据单元。
>
> ![img](https://img-blog.csdnimg.cn/20201023201906430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （3）用下述3条规则从描绘数据结构的Jackson图导出描绘程序结构的Jackson图。
>
> ![img](https://img-blog.csdnimg.cn/20201023202046595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （4）列出所有操作和条件(包括分支条件和循环结束条件)，并且把它们分配到程序结构图的适当位置。
>
> ![img](https://img-blog.csdnimg.cn/20201023202706913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201023202115211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> （5）用伪码表示程序。
>
> ![img](https://img-blog.csdnimg.cn/20201023202135620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> ![img](https://img-blog.csdnimg.cn/20201023202138582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)

## 5 程序复杂程度的定量度量

> 定量度量程序复杂程度的方法很有价值：
>
> （1）把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量。
>
> （2）定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣。
>
> （3）程序的定量的复杂程度可以作为模块规模的精确限度。

### 5.1 McCabe方法

> **1 流图**
>
> McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的<font color='red'>环形复杂度</font>。
>
> <font color='red'>**流图**</font>**实质上是“退化了的”程序流程图，描绘程序的控制流程，不表现对数据的具体操作以及分支或循环的具体条件。**
>
> ![img](https://img-blog.csdnimg.cn/20201023211239369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> <font color='red'>**由PDL翻译成流图技巧：没有分支连一块，遇上分支再分开**</font>
>
> ![img](https://img-blog.csdnimg.cn/2020102321242119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 复合条件，就是在条件中包含了一个或多个布尔运算符(逻辑OR，AND，NAND，NOR)
>
> ![img](https://img-blog.csdnimg.cn/2020102321302053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTkyNjkz,size_16,color_FFFFFF,t_70)
>
> 计算环形复杂度的方法
>
> （1）流图中线性无关的区域数等于环形复杂度。
>
> （2）流图G的环形复杂度 $V(G)=E-N+2$ ，其中，**E是流图中边的条数，N是结点数。**
>
> （3）流图G的环形复杂度 $V(G)=P+1$ ，其中，**P是流图中判定结点的数目**。
>
> 环形复杂度的用途
>
> （1）对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。
>
> （2）实践表明，模块规模以V(G)≤10为宜

### 5.2 Halstead方法

> 根据程序中运算符和操作数的总数来度量程序的复杂程度：
>
> - 令 $N_1$ 为程序中运算符出现的总次数，$N_2$ 为操作数出现的总次数，程序长度 $N$ 定义为：$N = N_1 + N_2$
> - 程序中使用的不同运算符（包括关键字）的个数 $n_1$，以及不同操作数（变量和常数）的个数 $n_2$，Halstead给出预测程序长度的公式如下：$H=n_1 log_2 n_1+n_2 log_2n_2$ 
> - 多次验证都表明，预测的长度H与实际长度N非常接近。
> - Halstead还给出了预测程序中包含错误的个数的公式如下：$E=Nlog_2 (n_1+n_2)/3000$

# 实现

## 软件测试的步骤

> 测试过程按4个步骤进行，即<font color='red'>单元测试（Unit Testing）</font>、<font color='red'>集成测试（Integrated Testing）</font>、<font color='red'>确认测试（Validation Testing）</font>和<font color='red'>系统测试（System Testing）</font>及发版测试。
>
> 黑盒测试 (Black box testing) ── 不考虑内部设计和代码，根据需求和功能进行测试。
>
> 白盒测试 (White box testing) ── 根据应用软件的代码的内部逻辑，按照代码的语句、分支、路径和条件进行测试。
>
> 功能测试（functional testing）——对一个应用软件的功能模块进行黑盒测试。这种测试应当由测试人员进行。但这并不意味着程序员在推出软件之前不进行代码检查。（这一原则适用于所有的测试阶段。）
>
> 系统测试 ── 针对全部需求说明进行黑盒测试，包括系统中所有的部件。
>
> 回归测试 (regression testing) ── 每当软件经过了整理、修改、或者其环境发生变化，都重复进行测试。很难说需要进行多少次回归测试，特别是是到了开发周期的最后阶段。进行此种测试，特别适于使用自动测试工具。
>
> 负荷试验 (load testing) ── 在大负荷条件下对应用软件进行测试。例如测试一个网站在不同负荷情况下的状况，以确定在什么情况下系统响应速度下降或是出现故障。
>
> 压力测试 (stress testing) ── 经常可以与“负荷测试”或“性能测试”相互代替。这种测试是用来检查系统在下列条件下的情况：在非正常的巨大负荷下、某些动作和输入大量重复、输入大数、对数据库进行非常复杂的查询，等等。
>
> 性能测试 (performance testing) ── 经常可以与“压力测试”或“负荷测试”相互代替。理想的“性能测试”(也包括其他任何类型的测试) 都应在质量保障和测试计划的文档终予以规定。
>

## 软件测试的方法

### 白盒测试技术

#### 1、逻辑覆盖法

原则：以程序内部的逻辑结构为基础设计测试用例。

逻辑覆盖包括**语句覆盖**、**判定覆盖**、**条件覆**盖、**判定／条件覆盖**、**条件组合覆盖**和**路径覆盖。**

以上六种覆盖标准发现错误的能力呈**由弱到强**变化：

1. 语句覆盖每条语句至少执行一次。
2. 判定覆盖每个判定的每个分支至少执行一次。
3. 条件覆盖每个判定的每个条件应取到各种可能的值。
4. 判定条件覆盖同时满足判定覆盖条件覆盖。
5. 条件组合覆盖每个判定中各条件的每一种组合至少出现一次。
6. 路径覆盖使程序中每一条可能的路径至少执行一次。

之所以六种覆盖标准发现错误的能力有差异，是因为使用每种覆盖标准所设计的测试用例对程序内部逻辑的**覆盖率**不同。

覆盖率是什么？

覆盖率是用来**度量测试完整性**的一个指标。

![img](https://img-blog.csdnimg.cn/098aabb998314c2b8dc2d69a4e1170b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

以下图的示例代码为例，分别说明每种覆盖标准的测试覆盖率。

![img](https://img-blog.csdnimg.cn/fe5ad2aee35b4b82a7ccc20cbb2cd314.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.1、语句覆盖（SC）**

语句覆盖：设计足够多的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现**运算中的逻辑关系错误**。

![img](https://img-blog.csdnimg.cn/3c3e9236e1fc49f78a037ffb5d336c1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_16,color_FFFFFF,t_70,g_se,x_16)

示例代码中共有4条可执行语句

设计测试用例执行了3条，语句覆盖率为3/4=75%

![img](https://img-blog.csdnimg.cn/67041d9218324cadab9cec92ff956090.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/69adc24d64804e50b25f0e2b7e8c0133.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.2、判定覆盖（DC）**

判定覆盖：设计足够多的测试用例，使得程序中的**每一个判断**至少**获得一次“真”和一次“假”**，即使得程序流程图中的**每一个真假分支至少被执行一次**。

但若程序中的判定是有几个条件联合构成时，未必能发现每个条件的错误。

![img](https://img-blog.csdnimg.cn/3e655bcd8a3b4542845511bf25ef9abd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/4419a68fb5e84bbbbc1e402a855665ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.3、条件覆盖（CC）**

条件覆盖：设计足够多的测试用例，使得运行这些测试用例时，使得判定中的**每个条件至少有一次取真值，有一次取假值**。

但未必能覆盖全部分支。

![img](https://img-blog.csdnimg.cn/f7c1a7f7a2454f7b82aeb1a5a243123d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_15,color_FFFFFF,t_70,g_se,x_16)

案例代码中有判定2个，条件3个，条件结果6个

设计测试用例执行了5个条件结果，条件覆盖率为5/6=83%

![img](https://img-blog.csdnimg.cn/9a5d868d60eb4a2498487f6a1277500d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/a02e6c0d34dc45938bafbb14d65ff117.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.4、判定／条件覆盖（DCC）**

判定／条件覆盖：设计足够多的测试用例，使得被测试程序中的**每个判断本身的判定结果（真假）至少满足一次**，同时，**每个逻辑条件的可能值（真假）也至少被满足一次**。

即同时**满足100%判定覆盖**和**100%条件覆盖**的标准。

![img](https://img-blog.csdnimg.cn/3addf7cb28934943b936b5bb3fbc4904.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_16,color_FFFFFF,t_70,g_se,x_16)

示例代码中有判定2个，条件3个，判定结果4个，条件结果6个

设计测试用例执行了3个判定结果，5个条件结果，判定条件覆盖率为：（3+5）/（4+6）=80%

![img](https://img-blog.csdnimg.cn/9fa75f2ed80a4e24ba8468e8d84d9011.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/1f5797a00c5741f797af43a02c446007.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.5、条件组合覆盖（BCCC）**

条件组合覆盖：设计足够多的测试用例，使得被测试程序中的**每个判定中条件结果**的**所有可能组合至少执行一次**。

显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。

示例代码中有判定2个，条件3个（判定1有2个条件，判定2有1个条件），判定1的条件组合为4个，判定2的条件组合为2个

设计测试用例执行了5个条件组合，条件组合覆盖率为：5/（4+2）=83%

![img](https://img-blog.csdnimg.cn/6d324b47a40c4f328c6d5c54af108f8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)



 ![img](https://img-blog.csdnimg.cn/34a93284c3ea40d991b509d4b47b04ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

##### **1.6、路径覆盖**

路径覆盖：设计足够多的测试用例，**覆盖被测试程序中的所有可能路径，**是最强的覆盖准则。

案例代码中共有4条路径

设计测试用例执行了3条路径，路径覆盖率为3/4=75%

![img](https://img-blog.csdnimg.cn/e5a2c500261947bc8e6a35253a0e855f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_19,color_FFFFFF,t_70,g_se,x_16)

#### **2、基本路径测试法**

理想情况下，**路径覆盖**需要覆盖程序中所有可能的路径。但在路径数目很大时，真正做到完全覆盖是很困难的，

必须把**覆盖路径数目压缩**到一定限度。例如**程序中的循环体只执行一次**。

所以，**基本路径测试法**可以理解为压缩后的路径覆盖。

基本路径测试法如何操作？

在程序控制流图的基础上，通过分析程序的环路复杂性，导出基本可执行路径集合，从而设计测试用例。

**一条<font color='red'>独立路径</font>是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路**，通俗的来说就是该路径要比其他路径至少多一个新的路径，并且该路径应该是从头至尾的，不可间断。

![img](https://img-blog.csdnimg.cn/e00d9a81483d43e6918b09d72c5fdff2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

程序的控制流图：描述程序控制流的一种图示方法

程序环路复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数。

导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。

准备测试用例：确保基本路径集中的每一条路径的执行。

![img](https://img-blog.csdnimg.cn/6d7d08332f794ccca8f39b6489d5e54b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/639ba1e6dace4e6bb00c4243e80f79dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZSm6YO95LiN5LqM,size_20,color_FFFFFF,t_70,g_se,x_16)

### 黑盒测试技术

> 黑盒测试也称为功能测试和数据驱动测试。它将被测软件视为一个无法打开的黑盒，主要根据功能需求设计测试用例和测试。把产品软件想象成一个只有出口和入口的黑盒。在测试过程中，你只需要知道向黑盒输入什么，知道黑盒会产生什么结果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d6941dd7a5b34155b43436e3fcfbee73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_20,color_FFFFFF,t_70,g_se,x_16)

> 黑盒测试方法主要有**等价类划分**、**边界值分析**、**错误推测**等，主要用于软件验证测试。**“黑盒”法侧重于程序的外部结构，不考虑内部逻辑结构，针对测试软件界面和软件功能。**“黑盒”方法是详尽的输入测试，只有当所有可能的输入都用作测试条件时，才能以这种方式检测程序中的所有错误。事实上，有无数个测试用例。人们不仅要测试所有合法的输入，还要测试那些非法但可能的输入。

#### 1、等价类划分法

根据程序的I/O特性，将程序的定义域划分为有限个等价区段 —“**等价类**”，从等价类中选择出的用例，具有“代表性”。

等价类分为：

- 有效等价类

> 是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。《软件质量与测试》

即：符合程序要求，合理且有意义

- 无效等价类

> 是指对于程序的规格说明来说是不合理的，没有意义的输入数据构成的集合.利用无效等价类可检验程序是否实现了规格说明中所规定的功能和性能。《软件质量与测试》

即：不符合要求，不合理且有意义

***等价类划分法设计步骤***

- 确定等价类的原则在输入条件规定了取值范围或值的个数的情况下,可以确立一个有效等价类和两个无效等价类
- 在输入条件规定了输入值的集合或者规定了"必须如何"的条件的情况下,可以确立一个有效等价类和一个无效等价类
- 在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类在规定了输入数据的一组值(假定n个),并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类
- 在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类(符合规则和若干个无效等价类(从不同角度违度规则)
- 在确知己划分的等价类中,各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步地划分为更小的等价类

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea306df93fb54cea9931f8f02d3d287a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_16,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/e87634ccd18a47cdaa1d9b2040e8486c.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/cae15388743742e78f5327b705ae877f.png)

> 如果等价类中的一个测试数据不能捕获缺陷，那么选择该等价类中的其他测试数据也不会捕获缺陷；同样的，如果等价类中的一个测试数据能够捕获一个缺陷，那么选择该等价类中的其他数据测试也能捕获该缺陷。

> 注: 在寻找等价划分时，考虑吧软件的中具有的相似输入、相似输出、相似操作的分在一起，这写组就是等价划分。
> 如果为了减少测试用例的数量过度划分等价类，就有漏掉哪些可能暴露软件缺陷的测试风险。

#### 2、边界值分析法

> 边界值分析是通过选择等价类边界的测试用例。边界值分析法不仅重视输入条件边界，而且也必须考虑输出域边界。它是对等价类划分方法的补充。《软件质量与测试》

即：对软件的输入或输出边界进行测试 作为等价类划分法的一种补充测试

![在这里插入图片描述](https://img-blog.csdnimg.cn/9426218419f142658c19238895a84ce2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQSAg5pyo5qKT,size_20,color_FFFFFF,t_70,g_se,x_16)
边界值只是一个特定的数据。
例如,文本框需要输入6到18位字符。
边界值有:

1. 6字符
2. 18 字符
   次边界。边界附近的值,按照系统规定的单位或者计算方式,一个数据的差异。
   例如,字符就是个,一个字符,没有半个字符的说法;人民币金额,最小单位是0.01元(1分), ATM机取款和存款,最小单位就是100元,只能是100元的整数倍

##### 边界值的选择原则

- 如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据
- 如果输入条件规定了值的个数,则用最大个数、最小个数、比最小个数少1、比最大个数多1的数作为测试数据
- 根据规格说明的每个输出条件,使用前面的原则①
- 根据规格说明的每个输出条件,应用前面的原则②
- 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例
- 如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构边界上的值作为测试用例。

> 等价类划分方法和边界值分析方法着重考虑输入条件，而不考虑输入条件的各种组合，也不考虑输入条件之间的相互制约关系。

#### 3、错误推测法

错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。

错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。

> 例如，在单元测试时曾列出的许多在模块中常见的错误。以前产品测试中曾经发现的错误等，这些就是经验的总结。还有，输入数据和输出数据为0的情况。
> 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。

# 面向对象编程

## 1 面向对象方法学

### 1.1 面向对象方法学概述

**面向对象编程**（Object-Oriented Programming，简称OOP）是一种编程范式，尽可能使用人的思维方式，将数据和操作数据的方法打包在一起，形成一个对象。对象可以被看作是现实世界中的一个实体，具有属性和行为。

面对对象方法具有下面4个要点：

> 1、认为客观世界是由各种对象组成的，任何事物都是对象，复杂的对象可以由比较简单的对象由某种方式组合而成。
>
> 2、把所有对象划分为各种对象类(class)，每个对象类定义了一组数据和操作数据的方法。
>
> 3、按照子类和父类的关系，把若干个对象类组成一个层次结构系统。
>
> 4、对象彼此之间仅能通过传递消息互相通讯。
>
> 综上所述，面向对象的方法可以用下列的方程来概述：
>
> ​			**OOP 	= 	 objects 	+ 	classes	+	inheritance	+	communication with messages**

### 1.2 面向对象方法学优点

> 面向对象方法学有以下几个优点：
>
> 1. 与人类习惯的思维方式一致
> 2. 稳定性较好
> 3. 可重用性好
> 4. 交易开发大型软件产品
> 5. 可维护性好

### 1.3 面向对象的三大特性

#### 继承（Extend）

> 继承是指从已有的类中派生出新的类，新类继承了原有类的所有数据和方法，并可以在此基础上进行扩展或重写。继承可以减少代码的重复，提高代码的复用性，同时也能够使代码更加清晰和易于维护。

> **继承的优点：**
>
> - 提高类代码的复用性
>
> - 提高了代码的维护性
>
> - 使得类和类产生了关系，是多态的前提(它也是继承的一个弊端，类的耦合性提高了)

#### 封装（Encapsulation)

> 封装是指将对象的数据和方法隐藏在类内部，只向外界提供接口（public方法）来访问。封装使得数据和方法的实现细节对外部隐藏，使得程序更加安全、稳定、易于维护和修改。

> **封装的优点：**
>
> - 通过封装，我们可以保护代码被破坏，提高数据安全性。
>
>   使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑限制对属性的不合理操作。
>
> - 通过封装，我们提高了代码的复用性（有些方法、类在很多地方都能多次反复使用）
>
> - 通过封装，带来的高内聚和低耦合，使用不同对象、不同模块之间能更好的协同，同时便于修改，增强代码的可维护性
>
>   - 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；
>   - 低耦合 ：仅对外暴露少量的方法用于使用

#### 多态（Polymorphism）

> 多态同一个行为具有多个不同表现形式或形态，从编程语言上讲就是同一个接口可以实现多种不同的行为。在OOP中，多态可以通过**C++虚函数、函数重载、Java接口**等方式实现。多态可以让程序更加灵活，提高程序的可扩展性和可维护性。
>
> Java中的多态性可以分为两种：
>
> 1. <font color='cornflowerblue'>**方法多态性**</font>：重载与覆写
>
>    重载：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能。
>    覆写：同一个方法，根据操作的子类不同，所完成的功能也不同。
>
> 2. <font color='cornflowerblue'>**对象多态性**</font>：父子类对象的转换。
>
>    向上转型：子类对象变为父类对象，格式：父类 父类对象 = 子类实例，自动；
>    向下转型：父类对象变为子类对象，格式：子类 子类对象 = (子类)父类实例，强制。

综上所述，OOP通过抽象、封装、继承和多态等特性，使得程序更加清晰、安全、稳定、易于维护和修改，同时也提高了代码的复用性和可扩展性。OOP已成为现代程序设计的主流范式之一，广泛应用于各个领域的程序设计和开发中。

#### 补充特征：抽象（Abstract)

> **抽象是从众多的事物中抽取出共同的、本质属性的特征，而舍弃其非本质的特征的过程。**具体地说，抽象就是人们在实践的基础上，对于丰富的[感性材料](https://baike.baidu.com/item/感性材料/5050824)通过去粗取精、去伪存真、由此及彼、由表及里的加工制作，形成[概念](https://baike.baidu.com/item/概念/829047)、[判断](https://baike.baidu.com/item/判断/33345)、[推理](https://baike.baidu.com/item/推理/1905524)等[思维形式](https://baike.baidu.com/item/思维形式/2302226)，以反映事物的本质和[规律](https://baike.baidu.com/item/规律/3311038)的方法。
>
> ​    其实说白了，抽象就是把事物的共同特征总结为一点。 他和具体又是相对的。就比如说“男人”对于“人类”是具体的，而“动物”对于“人类”又是抽象的。抽象---》抽出相同特征的对象，他也有个同义词叫归类。

## 2 面向对象的概念

### 2.1 对象

#### 2.1.1 对象的概念

> **对象（Object）**指的是对问题域中某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与他交互的能力，换句话来说，<font color='red'>对象就是属性值和操作的封装</font>。

#### 2.1.2 对象的特点

> 1. 以数据为中心
> 2. 对象是主动的
> 3. 实现了数据的封装
> 4. 本质上具有并行性
> 5. 模块独立性较好

#### 2.1.3 其他概念

##### 类

> 类（class）是对具有相同数据和相同操作的一组相似对象的集合。类的定义包括了在类中的一组数据和在类中的操作数据的方法。

## 3 面向对象建模

> tips：模型就是对事物做出的一组抽象，是对失误的一中无歧义的书面描述。

### 3.1 对象模型

#### 3.1.1 类图

##### 类图基本符号

> #### 类的定义
>
> UML中类的图形符号为**长方形**，用两条横线把长方形分**上、中、下**3个区域，3个区域分别放类**的名字、属性和服务**
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/289eee0464d14e3eae62fbbd8271d215.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_10,color_FFFFFF,t_70,g_se,x_16)

> ##### 属性具体格式为
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/1ee954bc72314eb39f8b5ad1b03428c1.png)
>
> - **可见性**：有公有的（+）、私有的（-）和保护的（#）
> - **类型名**：表示该属性的数据类型
> - **赋值**：在创建类的实例时应给其他属性赋值，如果给某个属性定义了初值，则该初值可作为创建实例时这个属性的默认值
> - **性质串**：明确地列出该属性所有可能取值，用逗号隔开
>
> **例如：- 货单数 : Integer = 0**

> ##### 服务具体格式为
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f12ee5b188ed400fa583855d6afbb949.png)
>
> - **可见性**：有公有的（+）、私有的（-）和保护的（#）
> - **参数表**：用逗号隔开不同参数，每个参数语法为 “`参数名:类型名=默认值`”

##### 表示关系的符号

###### （1）关联

> **定义**
>
> 关联表示两个类的对象之间存在某种**语义上的联系**
>
> 在任何关联中都会涉及**参与此关联的对象所扮演的角色**，在某些情况下显式标明角色名有助于别人理解类
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/7fe729dc68b146749fed5683020684e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> - 如果没有显式标出角色名，则意味着用类名作为角色名

> **普通关联**
>
> ①：定义
>
> 普通关联是最常见的关联关系，**只要在类与类之间存在连接关系就可以用普通关联表示**
>
> ②：表示
>
> - 第一，普通关联的图示符号是**连接两个类之间的直线**，如下图
> - 第二，关联是**双向**的，可为关联起一个名字。在名字前面(或后面)加一个**表示关联方向的黑三角**
> - 第三，在表示关联的直线两端可以写上**重数**，它表示该类有多少个对象与对方的一个对象连接。**未明确标出关联的重数，则默认重数是1**
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/0884f8bd8ba94f93be1ab862485f742c.png)

>  **限定关联**
>
> ①：定义
>
> 限定关联通常用在**一对多或多对多**的关联关系中，可以把模型中的重数从[一对多](https://so.csdn.net/so/search?q=一对多&spm=1001.2101.3001.7020)变成一对一， 或从多对多简化成多对一
>
> ②：表示
>
> 在类图中把**限定词**放在关联关系**末端的一个小方框内**。![在这里插入图片描述](https://img-blog.csdnimg.cn/e84060716e6d4a8f9bb46bad60a3b7e5.png)
>
> - 利用限定词“文件名”表示了目录与文件之间的关系，利用限定词把**一对多关系简化成了一对一关系**
>
> ③：意义
>
> 限定提高了语义精确性，增强了查询能力

> **关联类**
>
> ①：定义
>
> 为了说明关联的性质，可能需要一些**附加信息**。关联类可以用来**记录相关信息**
>
> ②：表示
>
> 关联类通过一条**虚线**与关联连接
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/23d3625cdc294078b93ed7a2f1ce1ce2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> - 关联中的每个连接与关联类的一个对象相联系

###### （2）聚集（它是关联的特例）

###### （3）泛化（本质就是继承）

###### （4）依赖和细化

### 3.2 动态模型

### 3.3 功能模型

