---
title: 高级软件工程
date: 2023年9月22日20:28:17
tags: 
    - 软件工程
    - 课堂学习
categories: 计算机基础学科
keywords:
description: 
top_img: https://w.wallhaven.cc/full/qz/wallhaven-qzom1r.jpg
comments:
cover: https://w.wallhaven.cc/full/qz/wallhaven-qzom1r.jpg
toc: 
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:


---

<meta name="referrer" content="no-referrer"/>

# 一、软件工程概述

软件工程的难点：

1. 适合的解决方式来解决用户需求
2. 高质量代码
3. 时间与金钱成本必须是可预测且可控的

好的软件如何度量：好的软件需要传递用户需要的功能性和表现，应该是可维护、可靠和可用的。



敏捷编程的用户故事：让用户参与到故事之中，即用户与机器的交互的场景，根据交互来进行编程。

## 1.1 软件工程

追求开发高质量软件

## 1.2 SaaS

Software as a Service
SaaS通过运行在客户端上的瘦程序（即程序本身没有多少功能，其功能调用API获取），访问在Internet上的服务形式提供的软件。

SaaS的优势：

1. 无需安装，不需要担心硬件和OS差异
2. 无需担心数据丢失
3. 便于数据的分享
4. 软件单一拷贝，单一部署硬件/软件环境

SaaS开发的框架/语言：Spring/Java，Django/Python，Rails/Ruby，Ruby是一种现代动态脚本编程语言 ，拥有面向对象、函数式、自动内存管理等

SaaS依赖的基础设施：

1. 通讯：允许客户与服务交互
2. 可扩展性：需求波动可以满足 + 新服务快速引入
3. 可靠性：服务和通性 7 x 24 小时可用

## 1.3 面向服务的架构

面向服务的架构（Service Oriented Architecture），称SOA即所有组件都设计为服务，且服务可用组合的软件架构。每一个子系统都是独立的，就像独立的数据中心中一样。
竖井式架构（Silo Architecture）：内部子系统可用直接共享数据，所有子系统都在单一的API中。

SOA主要通过重用来提高开发人员的生产力，任何SOA服务器都不能直接调用其他服务器中的数据，只能够调用其他服务器系统中提供的API来实现功能的交互。SOA提高了系统分解的能力，使得系统开发更为规范化、结构化。
相较于Silo模式，SOA模式服务之间的调用经过网络调用，其性能会受到网络波动的影响，二Silo模式数据调用直接在进程间执行，性能更好。SOA与Silo性能的差距，可以使用缓存来缩小。

## 1.4 云计算（Cloud Computation）

集群：由普通以太网联结的普通交换机，其具有下面特点：

1. 具有更好的可伸缩性
2. 使用冗余来实现可靠性

## 1.5 软件质量

验证（Verification）：你构建的东西正确吗？是否符合规范？
校验（Validation）：你构建的是对的东西吗？是客户想要的吗？

# 二、软件过程

## 2.1 P&D软件过程

计划与文档（P&D）：

– 编码前，项目经理制定计划

– 撰写计划各阶段的详细文档

– 根据计划来度量进展

– 项目的变更必须反映在文档中，并可能反映在计划中

### 瀑布式开发模型

### 螺旋模型

瀑布模型 + 原型

### Rational统一软件开发过程

RUP有下面四个阶段：
1. 初始阶段
2. 精化阶段
3. 构建阶段
4. 迁移阶段

## 2.2 敏捷开发

### 敏捷开发宣言

- 个体与交互 over 过程&工具
- 工作软件 over 全面的文档化
- 客户写作 over 客户谈判
- 响应变化 over 遵从计划

也就是说，虽然右边的条目有价值，但是我们更看重左边的条目。

### 极限编程（XP）

- 如果短迭代是好的，那么让它们尽可能短(周 vs. 年)
- 如果简单是好的，尽量做可能有效且最简单的事情
- 如果测试是好的，就保持测试。在编写测试代码之前先编写测试代码。
- 如果代码检查很好，那么就通过结对编程，轮流检查彼此，不断地检查代码。

### 敏捷生命周期

• 拥抱变化，它就是现实: 持续改进 vs. 阶段
• 开发人员持续改进不完整的原型，直到客户满意为止，每次迭代都有客户的反馈(每1~2 周)
• 敏捷强调测试驱动开发(TDD)来减少错误，记录用户故事来验证客户需求，用速度来度量进展

敏捷开发vsP&D

# 三、Ruby程序设计语言

## 3.1 初识Ruby

**Ruby**的特性：

- Ruby是一种高级程序设计语言
- Ruby是一种面向对象的语言
- Ruby是一种解释型语言（例如Python），通过解释器边解释边执行。
- Ruby是一种动态类型、强类型语言。

- - 静态类型与动态类型：变量是否可以引用所有变量类型，是则是动态类型。
  - 强类型与弱类型：是否存在不同类型变量进行隐式转换，允许则是弱类型。

- Ruby允许元编程。

## 3.2 Ruby基础

### 注释

在 Ruby 中，您可以使用以下方式添加注释：

1. 单行注释：使用 `#` 符号在一行的开头添加注释。该行后的任何内容都将被视为注释。 

```ruby
# 这是一个单行注释
puts "Hello, World!" # 这是另一个单行注释
```

2. 多行注释：使用 `=begin` 和 `=end` 来包围多行注释。 

~~~ruby
=begin
这是一个多行注释
这里可以写多行注释内容
=end
```
~~~

请注意，Ruby 中的注释只是在代码执行过程中被忽略的文本，用于提供代码的解释、说明和文档。它们不会被编译或执行。注释对于帮助其他开发人员理解您的代码以及对代码进行调试和维护非常有用。

------

### 定义变量

在 Ruby 中，可以使用以下方式定义变量：

1.  **局部变量**（Local Variables）：局部变量以小写字母或下划线开头。它们的作用域限制在当前的代码块或方法中。 

```ruby
name = "Alice"
age = 25
_count = 10
```

2. **实例变量**（Instance Variables）：实例变量以 `@` 符号开头。它们的作用域限制在当前对象的实例中。 

```ruby
@name = "Alice"
@age = 25
```

3. **类变量**（Class Variables）：类变量以 `@@` 符号开头。它们的作用域限制在当前类及其子类中。 

```ruby
@@count = 10
```

3. **全局变量**（Global Variables）：全局变量以 `$` 符号开头。它们的作用域在整个 Ruby 程序中都是可见的。 

```ruby
$global_variable = "Hello"
```

4. **常量**（Constants）：常量以大写字母开头。它们的值在定义后不能被改变，常量不能在方法（函数）中定义。

```ruby
PI = 3.14159
MAX_VALUE = 100
```

5. **伪变量**：伪变量不是真正的变量，其无法被重新赋值，但是可以获取当前某些属性。

```ruby
1. self：表示当前对象的引用。在类定义中，self指的是类本身；在实例方法中，self指的是调用该方法的对象；在类方法中，self指的是类本身。

2. true、false和nil：表示布尔值和空值。true表示真，false表示假，nil表示空值。

3. __FILE__：表示当前文件的文件名。

4. __LINE__：表示当前代码所在的行号。
```

请注意，变量在使用之前需要先进行初始化，可以直接赋值或通过其他方式进行赋值。变量名应具有描述性且易于理解，以提高代码的可读性。

------

#### 定义方法

在 Ruby 中，你可以使用 `def` 关键字来定义方法。以下是定义方法的基本语法：

```ruby
def 方法名(参数1, 参数2, ...)
  # 方法体
end
```

在上面的语法中，`def` 关键字用于声明方法的开始，后面紧跟方法名和参数列表。参数列表是可选的，你可以根据需要在括号中列出方法的参数。方法体是方法的实际代码，它包含在 `def` 和 `end` 关键字之间。

下面是一个简单的示例，展示如何定义一个接受参数并打印输出的方法：

```ruby
def greet(name)
  puts "Hello, #{name}!"
end
```

你可以调用定义的方法，方法调用将执行方法体中的代码。调用方法时，你需要提供方法所需的参数。例如：

```ruby
greet("Alice")
```

上述代码将调用 `greet` 方法，并将字符串 "Alice" 作为参数传递给它。方法将输出 "Hello, Alice!"。

Ruby方法可以返回参数值使用关键字`return`，后跟要返回的值。以下是一个示例：

```ruby
def add_numbers(a, b)
  sum = a + b
  return sum
end

result = add_numbers(3, 4)
puts result # 输出：7
```

需要注意的是，**Ruby方法的最后一个表达式的值将被默认作为返回值**，因此在上面的例子中，可以省略`return`关键字，直接使用`sum`作为返回值：

```ruby
def add_numbers(a, b)
  sum = a + b
  sum
end
```

当定义方法时，你可以为**参数提供默认值**，这样在调用方法时，如果没有提供相应的参数值，就会使用默认值。你可以使用以下语法来指定默认参数：

```ruby
def 方法名(参数1 = 默认值1, 参数2 = 默认值2, ...)
  # 方法体
end
```

默认参数的定义放在参数列表中，使用等号 `=` 后跟默认值。如果调用方法时没有为参数提供值，那么默认值将被使用。以下是一个使用默认参数的示例：

```ruby
def greet(name = "Guest")
  puts "Hello, #{name}!"
end
```

在上面的示例中，`greet` 方法的 `name` 参数有一个默认值 "Guest"。如果调用方法时没有传递参数，将使用默认值 "Guest"。例如：

```ruby
greet("Alice")  # 输出 "Hello, Alice!"
greet          # 输出 "Hello, Guest!"
```

另外，Ruby 还支持**可变参数**，这意味着你可以在方法定义中接受不确定数量的参数。你可以在参数名前加上 `*` 来指定可变参数。在方法体内，可变参数将作为数组进行处理。以下是一个使用可变参数的示例：

```ruby
def sum(*numbers)
  total = 0
  numbers.each do |num|
    total += num
  end
  total
end
```

在上面的示例中，`sum` 方法接受任意数量的参数，并将它们相加得到总和。你可以传递任意数量的参数给方法，它们将作为数组 `numbers` 在方法体内使用。例如：

```ruby
puts sum(1, 2, 3)  # 输出 6
puts sum(4, 5)     # 输出 9
puts sum(6)        # 输出 6
puts sum           # 输出 0
```

此外，Ruby 还提供了块（Block）的概念，它是一种用于传递代码的结构。你可以使用块来扩展方法的功能，使其更加灵活。在方法定义中，可以使用 `yield` 关键字来调用块。以下是一个使用块的示例：

```ruby
def process
  puts "Start"
  yield if block_given?
  puts "End"
end
```

在上面的示例中，`process` 方法在执行时，会先输出 "Start"，然后调用块（如果有提供块），最后输出 "End"。你可以在调用方法时传递一个块，块中的代码将在 `yield` 处执行。例如：

```ruby
process do
  puts "Processing..."
end
```

上述代码将输出：

```plain
Start
Processing...
End
```

------

#### 异常

在Ruby中，异常处理是一种用于处理错误和异常情况的机制。当程序发生错误或遇到无法处理的情况时，会引发异常。以下是Ruby中异常处理的基本概念和用法。

1.  **抛出异常**（Raise Exception）：
   在Ruby中，可以使用`raise`关键字抛出异常。`raise`语句通常包含一个异常类（可以是内置的异常类或自定义的异常类）和一个可选的错误消息。 

```ruby
raise ExceptionClass, "Error message"
```

例如，下面的代码抛出一个`RuntimeError`异常：

```ruby
raise RuntimeError, "Something went wrong"
```

 

2. **捕获异常**（Catch Exception）：
   可以使用`begin`和`rescue`关键字来捕获异常。`begin`块中的代码被监视，如果发生异常，会跳转到`rescue`块，并执行相关的处理代码。 

``rescue`` 块可以捕获特定类型的异常，也可以使用`Exception`来捕获所有类型的异常。

例如，下面的代码捕获`RuntimeError`异常并进行处理：

```ruby
begin
  # 可能会引发异常的代码
rescue RuntimeError => e
  puts "Error occurred: #{e.message}"
end
```

3. **处理多个异常**：
   可以在`rescue`块中处理多个异常，每个异常使用不同的`rescue`子句。 

```ruby
begin
  # 可能会引发异常的代码
rescue ExceptionClass1
  # 处理异常的代码
rescue ExceptionClass2
  # 处理异常的代码
end
```

 例如，下面的代码捕获`RuntimeError`和`ArgumentError`两种异常：

```ruby
begin
  # 可能会引发异常的代码
rescue RuntimeError
  # 处理 Runtime Error 的代码
rescue ArgumentError
  # 处理 Argument Error 的代码
end
```

4. **最终处理**（Ensure）：
   可以使用`ensure`关键字定义一个最终处理块，其中的代码无论是否发生异常都会执行。 

```ruby
begin
  # 可能会引发异常的代码
rescue ExceptionClass
  # 处理异常的代码
ensure
  # 最终处理的代码
end
```

 例如，下面的代码无论是否发生异常，都会执行最终处理块中的代码：

```ruby
begin
  # 可能会引发异常的代码
rescue RuntimeError => e
  puts "Error occurred: #{e.message}"
ensure
  puts "Final processing"
end
```

这些是Ruby中异常处理的基本概念和用法。通过使用`raise`抛出异常，`begin`、`rescue`和`ensure`来捕获和处理异常，可以有效地处理错误和异常情况，提高程序的健壮性和可靠性.

## 3.3 Ruby 面向对象

#### 定义对象

在Ruby中，可以通过定义类来创建对象。类是对象的蓝图，它定义了对象的属性和行为。以下是在Ruby中定义对象的步骤：

1. 使用关键字`class`定义一个类，后面跟着类的名称。类名的首字母通常大写。例如：

```ruby
class Person
  # 对象定义
end
```

1. 在类中定义实例变量作为对象的属性。实例变量以`@`符号开头，可以在类的任何方法中使用。例如：

```ruby
class Person
  def initialize(name, age)
    @name = name
    @age = age
  end
end
```

1. 在类中定义方法作为对象的行为。方法是类中的函数，可以执行特定的操作。例如：

```ruby
class Person
  def initialize(name, age)
    @name = name
    @age = age
  end
  
  def introduce
    puts "My name is #{@name} and I am #{@age} years old."
  end
end
```

上述例子中，`initialize`方法可以看作构造函数，构造函数使用`@` 关键字修饰的变量可以看作类的属性，同时也可以显示定义类的属性，使用关键字`@@`修饰，例如：

```ruby
class MyClass
  @@class_var = 20
end

puts MyClass.class_variables
```

运行上述代码会输出`@@class_var`的值，它是`MyClass`类的一个类变量。

1. 使用类的`new`方法创建对象。`new`方法是类的构造函数，用于实例化对象并调用`initialize`方法进行初始化。例如：

```ruby
person = Person.new("John", 25)
```

1. 可以通过对象调用类中定义的方法。例如：

```ruby
person.introduce
```

这将输出：`My name is John and I am 25 years old.`

------

#### 封装对象

在Ruby中，类的封装是通过访问控制符（Access Control）来实现的。Ruby提供了三种访问控制符，分别是`public`、`private`和`protected`，用于控制类中方法和属性的可见性。

1. `public`：公共方法可以从类的内部和外部访问。默认情况下，所有的方法都是公共的。

```ruby
class MyClass
  def public_method
    puts "This is a public method"
  end
end

obj = MyClass.new
obj.public_method # 调用公共方法
```

1. `private`：私有方法只能从类的内部调用，无法从外部直接访问。私有方法不能被类的实例直接调用，只能通过类的内部方法来间接调用。

```ruby
class MyClass
  def public_method
    puts "This is a public method"
    private_method # 可以在类的内部调用私有方法
  end

  private

  def private_method
    puts "This is a private method"
  end
end

obj = MyClass.new
obj.public_method # 调用公共方法，会间接调用私有方法
# obj.private_method # 错误！无法直接调用私有方法
```

1. `protected`：受保护方法可以从类的内部以及该类的实例的上下文中访问。受保护方法可以被类的实例直接调用，也可以在同一个类的其他实例方法中调用。

```ruby
class MyClass
  def public_method
    puts "This is a public method"
    protected_method # 可以在类的内部调用受保护方法
  end

  protected

  def protected_method
    puts "This is a protected method"
  end
end

obj = MyClass.new
obj.public_method # 调用公共方法，会直接调用受保护方法
# obj.protected_method # 错误！不能直接调用受保护方法
```

通过使用这些访问控制符，可以控制类中方法和属性的可见性，实现封装的概念。这样可以隐藏内部实现细节，防止外部直接访问和修改类的内部状态，提供了更好的封装性和安全性。型。               

